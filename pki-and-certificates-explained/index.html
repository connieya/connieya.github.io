<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.14.5"/><meta data-react-helmet="true" name="description"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" http-equiv="Content-Type" content="text/html;charset=UTF-8"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:title" content="내 공개키는 내가 만들었는데, 왜 CA가 보증해야 하죠?"/><meta data-react-helmet="true" property="og:description"/><meta data-react-helmet="true" property="og:image"/><meta data-react-helmet="true" property="og:url"/><meta data-react-helmet="true" property="og:site_name" content="내 공개키는 내가 만들었는데, 왜 CA가 보증해야 하죠?"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="내 공개키는 내가 만들었는데, 왜 CA가 보증해야 하죠?"/><meta data-react-helmet="true" name="twitter:description"/><meta data-react-helmet="true" name="twitter:image"/><meta data-react-helmet="true" name="twitter:site" content="@사용자이름"/><meta data-react-helmet="true" name="twitter:creator" content="@사용자이름"/><meta data-react-helmet="true" name="google-site-verification" content="웹 마스터 도구가 제공하는 Meta 태그"/><meta data-react-helmet="true" name="naver-site-verification" content="웹 마스터 도구가 제공하는 Meta 태그"/><style data-href="/styles.9e907bc32054b7771552.css" data-identity="gatsby-global-css">code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">내 공개키는 내가 만들었는데, 왜 CA가 보증해야 하죠?</title><link rel="sitemap" type="application/xml" href="/sitemap-index.xml"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="canonical" href="https://connieya.github.io/pki-and-certificates-explained/" data-baseprotocol="https:" data-basehost="connieya.github.io"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 11pfcjj">.css-11pfcjj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;}</style><div class="css-11pfcjj esjg9ma0"><style data-emotion="css 123clne">.css-123clne{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:7rem;}</style><div class="css-123clne e1o8p83g2"><style data-emotion="css 1dg0t7z">.css-1dg0t7z{width:100%;max-width:768px;margin:0 auto;}</style><div class="css-1dg0t7z e1o8p83g1"><style data-emotion="css 1yk9l7f">.css-1yk9l7f{font-size:1.5rem;font-weight:bold;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}</style><a class="css-1yk9l7f e1o8p83g0" href="/">박건희</a></div></div><style data-emotion="css-global 4cqo99">*{padding:0;margin:0;box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}html,body,#___gatsby{height:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css 11k3q87">.css-11k3q87{position:relative;width:100%;max-width:768px;margin:0 auto;}</style><div class="css-11k3q87 e17f455w0"><style data-emotion="css jwelnu">.css-jwelnu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:2.5rem 1rem 2rem;max-width:768px;margin:0 auto;}@media (max-width: 768px){.css-jwelnu{padding:2rem 0.75rem 1.5rem;}}</style><div class="css-jwelnu ehbuenk4"><style data-emotion="css gjsprg">.css-gjsprg{word-break:keep-all;line-height:1.3;font-size:1.9rem;margin-bottom:1.3rem;}@media (max-width: 768px){.css-gjsprg{font-size:1.8rem;margin-bottom:0.8rem;}}</style><h1 class="css-gjsprg ehbuenk3">내 공개키는 내가 만들었는데, 왜 CA가 보증해야 하죠?</h1><style data-emotion="css 1r9pax5">.css-1r9pax5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;color:#757575;font-size:0.9rem;}@media (max-width: 768px){.css-1r9pax5{-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;}}</style><div class="css-1r9pax5 ehbuenk2"> <style data-emotion="css 1bmnxg7">.css-1bmnxg7{white-space:nowrap;}</style><div class="css-1bmnxg7 ehbuenk1">2024-12-21<style data-emotion="css uaob3j">.css-uaob3j{margin-left:0.5rem;}</style><span class="css-uaob3j ehbuenk0">약 <!-- -->6<!-- -->분</span></div></div></div><style data-emotion="css n5jjl">.css-n5jjl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;margin:0 auto;padding:1.5rem 0;line-height:1.75;word-break:break-all;}.css-n5jjl h1,.css-n5jjl h2,.css-n5jjl h3{margin-bottom:1.5rem;font-weight:700;}.css-n5jjl h1{padding-left:0.2rem;font-size:2rem;border-bottom:1px solid #e2e5e6;}.css-n5jjl h2{font-size:1.75rem;border-bottom:1px solid #e2e5e6;}.css-n5jjl h3{font-size:1.25rem;}.css-n5jjl *+h1,.css-n5jjl *+h2,.css-n5jjl *+h3{margin-top:2rem;margin-bottom:0.5rem;}.css-n5jjl hr+h1,.css-n5jjl hr+h2,.css-n5jjl hr+h3{margin-top:0;}.css-n5jjl blockquote{margin:30px 0;padding:0 1rem;color:#757575;font-weight:800;border-left:2px solid #e2e5e6;}.css-n5jjl ol,.css-n5jjl ul{margin-top:0rem;margin-bottom:0rem;margin-left:1rem;padding:0.5rem 0;}.css-n5jjl li{font-weight:300;}.css-n5jjl hr{margin:100px 0;border:1px solid #000;}.css-n5jjl a{color:#0E68C8;}.css-n5jjl p{margin:0;padding:0.5rem 0;font-weight:300;}.css-n5jjl img{margin:3rem 0;}.css-n5jjl pre[class*='language-'],.css-n5jjl code[class*='language-']{color:#d4d4d4;font-size:13px;font-family:Menlo,Monaco,Consolas,'Andale Mono','Ubuntu Mono','Courier New',monospace;direction:ltr;white-space:pre;text-align:left;text-shadow:none;word-break:normal;word-spacing:normal;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;border-radius:0.5rem;}.css-n5jjl pre[class*='language-']::selection,.css-n5jjl code[class*='language-']::selection,.css-n5jjl pre[class*='language-'] *::selection,.css-n5jjl code[class*='language-'] *::selection{text-shadow:none;background:#264f78;}@media print{.css-n5jjl pre[class*='language-'],.css-n5jjl code[class*='language-']{text-shadow:none;}}.css-n5jjl pre[class*='language-']{padding:1rem;overflow:auto;background:#1e1e1e;}.css-n5jjl:not(pre)>code[class*='language-']{padding:0.1em 0.3em;background:#1e1e1e;border-radius:0;border-radius:0.3em;}.css-n5jjl .namespace{opacity:0.7;}.css-n5jjl .token.doctype .token.doctype-tag{color:#569cd6;}.css-n5jjl .token.doctype .token.name{color:#9cdcfe;}.css-n5jjl .token.comment,.css-n5jjl .token.prolog{color:#6a9955;}.css-n5jjl .token.punctuation,.css-n5jjl .language-html .language-css .token.punctuation,.css-n5jjl .language-html .language-javascript .token.punctuation{color:#d4d4d4;}.css-n5jjl .token.property,.css-n5jjl .token.tag,.css-n5jjl .token.boolean,.css-n5jjl .token.number,.css-n5jjl .token.constant,.css-n5jjl .token.symbol,.css-n5jjl .token.inserted,.css-n5jjl .token.unit{color:#b5cea8;}.css-n5jjl .token.selector,.css-n5jjl .token.attr-name,.css-n5jjl .token.string,.css-n5jjl .token.char,.css-n5jjl .token.builtin,.css-n5jjl .token.deleted{color:#ce9178;}.css-n5jjl .language-css .token.string.url{-webkit-text-decoration:underline;text-decoration:underline;}.css-n5jjl .token.operator,.css-n5jjl .token.entity{color:#d4d4d4;}.css-n5jjl .token.operator.arrow{color:#569cd6;}.css-n5jjl .token.atrule{color:#ce9178;}.css-n5jjl .token.atrule .token.rule{color:#c586c0;}.css-n5jjl .token.atrule .token.url{color:#9cdcfe;}.css-n5jjl .token.atrule .token.url .token.function{color:#dcdcaa;}.css-n5jjl .token.atrule .token.url .token.punctuation{color:#d4d4d4;}.css-n5jjl .token.keyword{color:#569cd6;}.css-n5jjl .token.keyword.module,.css-n5jjl .token.keyword.control-flow{color:#c586c0;}.css-n5jjl .token.function,.css-n5jjl .token.function .token.maybe-class-name{color:#dcdcaa;}.css-n5jjl .token.regex{color:#d16969;}.css-n5jjl .token.important{color:#569cd6;}.css-n5jjl .token.italic{font-style:italic;}.css-n5jjl .token.constant{color:#9cdcfe;}.css-n5jjl .token.class-name,.css-n5jjl .token.maybe-class-name{color:#4ec9b0;}.css-n5jjl .token.console{color:#9cdcfe;}.css-n5jjl .token.parameter{color:#9cdcfe;}.css-n5jjl .token.interpolation{color:#9cdcfe;}.css-n5jjl .token.punctuation.interpolation-punctuation{color:#569cd6;}.css-n5jjl .token.boolean{color:#569cd6;}.css-n5jjl .token.property,.css-n5jjl .token.variable,.css-n5jjl .token.imports .token.maybe-class-name,.css-n5jjl .token.exports .token.maybe-class-name{color:#9cdcfe;}.css-n5jjl .token.selector{color:#d7ba7d;}.css-n5jjl .token.escape{color:#d7ba7d;}.css-n5jjl .token.tag{color:#569cd6;}.css-n5jjl .token.tag .token.punctuation{color:#808080;}.css-n5jjl .token.cdata{color:#808080;}.css-n5jjl .token.attr-name{color:#9cdcfe;}.css-n5jjl .token.attr-value,.css-n5jjl .token.attr-value .token.punctuation{color:#ce9178;}.css-n5jjl .token.attr-value .token.punctuation.attr-equals{color:#d4d4d4;}.css-n5jjl .token.entity{color:#569cd6;}.css-n5jjl .token.namespace{color:#4ec9b0;}.css-n5jjl pre[class*='language-javascript'],.css-n5jjl code[class*='language-javascript'],.css-n5jjl pre[class*='language-jsx'],.css-n5jjl code[class*='language-jsx'],.css-n5jjl pre[class*='language-typescript'],.css-n5jjl code[class*='language-typescript'],.css-n5jjl pre[class*='language-tsx'],.css-n5jjl code[class*='language-tsx']{color:#9cdcfe;}.css-n5jjl pre[class*='language-css'],.css-n5jjl code[class*='language-css']{color:#ce9178;}.css-n5jjl pre[class*='language-html'],.css-n5jjl code[class*='language-html']{color:#d4d4d4;}.css-n5jjl .language-regex .token.anchor{color:#dcdcaa;}.css-n5jjl .language-html .token.punctuation{color:#808080;}.css-n5jjl pre[class*='language-']>code[class*='language-']{position:relative;z-index:1;}.css-n5jjl .line-highlight.line-highlight{z-index:0;background:#f7ebc6;box-shadow:inset 5px 0 0 #f7d87c;}.css-n5jjl pre[class*='language-text'],.css-n5jjl code[class*='language-text']{padding:0.25rem;color:#000000;background-color:#e2e5e6;}@media (max-width: 768px){.css-n5jjl img{width:100%;}.css-n5jjl pre[class*='language-']{width:100%;overflow-x:auto;}}</style><div class="css-n5jjl e13plzdv0"><p>비대칭키를 처음 공부했을 때, 개인키와 공개키 한 쌍으로 모든 것이 해결되는 완벽한 시스템이라고 생각했습니다.</p>
<p>하지만 실무에서 결제 시스템의 코드를 들여다보며 한 가지 의문이 생겼습니다.</p>
<p>바로 "내 공개키는 내가 만들었는데, 왜 CA(인증 기관)라는 제3자가 보증해야 하는가?"라는 점이었습니다.</p>
<h2 id="이-공개키-정말-믿을-수-있을까" style="position:relative;"><a href="#%EC%9D%B4-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%A0%95%EB%A7%90-%EB%AF%BF%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C" aria-label="이 공개키 정말 믿을 수 있을까 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이 공개키, 정말 믿을 수 있을까?</h2>
<p>암호화의 기본은 대칭키와 비대칭키입니다. <strong><code class="language-text">대칭키</code></strong> 는 암호화 복호화에 같은 키를 쓰는 빠르고 단순한 방식이지만, 키를 상대방에게 안전하게 전달해야 하는 치명적인 약점이 있습니다.</p>
<p>그래서 등장한 것이 <strong><code class="language-text">비대칭키(공개키/개인키)</code></strong> 방식입니다.</p>
<p>데이터를 받을 수신자가 한 쌍의 키를 만들어, 암호화에 사용할 공개키는 모두에게 나눠주고 복호화에 필요한 개인키는 자신만 안전하게 보관하는 방식이죠. 키를 전달할 필요가 없으니 훨씬 안전해 보입니다.</p>
<p>"클라이언트 입장에서 서버의 공개키를 받아서 중요한 데이터를 암호화해야 한다. <br/>그런데 지금 내 손에 들어온 <strong>이 공개키 파일이 정말로 내가 통신하려는 그 서버의 것</strong>이라고 어떻게 확신할 수 있지?
<br/>만약 해커가 중간에서 자신의 가짜 공개키를 슬쩍 바꿔치기했다면 ?"</p>
<p>이게 바로 <strong><code class="language-text">'중간자 공격(Man-in-the-Middle Attack)'</code></strong> 이라는 공격 기법입니다.</p>
<p>클라이언트는 가짜 공개키인 줄도 모르고
열심히 데이터를 암호화해서 보낼 테고, 공격자는 그걸 자기 개인키로 유유히 열어보는 끔찍한 상황이었습니다. 모든 정보가 그대로 노출되는 거죠.</p>
<p>이 신뢰의 문제를 해결하기 위해 등장한 것이 바로 <strong><code class="language-text">디지털 인증서(Digital Certificate)</code></strong> 입니다.</p>
<h2 id="신뢰의-이름표-디지털-인증서-x509-certificate" style="position:relative;"><a href="#%EC%8B%A0%EB%A2%B0%EC%9D%98-%EC%9D%B4%EB%A6%84%ED%91%9C-%EB%94%94%EC%A7%80%ED%84%B8-%EC%9D%B8%EC%A6%9D%EC%84%9C-x509-certificate" aria-label="신뢰의 이름표 디지털 인증서 x509 certificate permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>신뢰의 이름표, 디지털 인증서 (X.509 Certificate)</h2>
<p>디지털 인증서는 공개키에 대한 공인된 '신원 보증서' 라고 할 수 있습니다.
이 신원 보증서는 아무나 발급할 수 없고, 모두가 신뢰하기로 약속한 제3자 기관인 <strong>CA(Certificate Authority, 인증 기관)</strong> 만이 발급할 수 있습니다.</p>
<p>인증서가 만들어지는 과정은 이렇습니다.</p>
<ol>
<li><strong>서버</strong>는 자신의 공개키와 신원 정보(도메인 주소 등)를 담아 CA에 <strong>CSR(Certificate Signing Request, 인증서 서명 요청)</strong> 을 보냅니다. 이 요청서에는 "이 공개키의 주인은 바로 나"라는 것을 증명하기 위해 자신의 개인키로 만든 <strong>전자서명</strong>이 포함됩니다.</li>
<li>CA는 서버의 신원을 여러 방법으로 검증하고, CSR이 유효하다고 판단되면 CA 자신의 개인키로 디지털 서명을 하여 공식적인 인증서를 발급해 줍니다.</li>
<li>이 인증서 안에는 <strong><code class="language-text">서버의 공개키</code></strong> + <strong><code class="language-text">서버의 신원 정보</code></strong> + <strong><code class="language-text">CA의 서명</code></strong> + <strong><code class="language-text">유효 기간</code></strong> 등 이 모두 담기게 됩니다.</li>
</ol>
<p>이제 클라이언트는 서버로부터 그냥 공개키가 아닌, 이 인증서를 전달받습니다. 그리고 자신의 컴퓨터(OS나 브라우저)에 이미 내장된 CA의 공개키를 이용해 인증서의 서명을 검증합니다.</p>
<p>서명이 유효하다면, "아, 이 인증서에 담긴 공개키는 위조되지 않았고, 신뢰할 수 있는 CA가 보증하는 진짜 서버의 것이 맞구나!"라고 확신할 수 있게 되는 것입니다.</p>
<h2 id="그럼-pki는-무엇일까" style="position:relative;"><a href="#%EA%B7%B8%EB%9F%BC-pki%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C" aria-label="그럼 pki는 무엇일까 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>그럼 PKI는 무엇일까?</h2>
<p>방금 '신뢰'를 구축하기 위해 CA, CSR, 디지털 인증서 같은 요소들이 어떻게 작동하는지 살펴봤습니다.</p>
<p><strong>PKI(Public Key Infrastructure, 공개키 기반 구조)</strong> 는 바로 이 모든 것을 포괄하는 거대한 '시스템' 또는 '인프라' 그 자체를 의미합니다.</p>
<ul>
<li>인증서를 만들고(CA)</li>
<li>인증서를 요청하고(CSR)</li>
<li>발급된 인증서를 사용하고 검증하며(신뢰의 사슬)</li>
<li>필요하면 인증서를 폐기하는(CRL/OCSP)</li>
</ul>
<p>이 모든 과정에 필요한 기술, 정책, 절차, 하드웨어, 소프트웨어 등을 총칭하는 용어가 바로 PKI입니다.</p>
<p>즉, 인증서는 PKI라는 거대한 신뢰 시스템이 만들어내는 핵심 '결과물'이고, CA는 이 시스템의 핵심 '구성원'인 셈입니다.</p>
<p>우리가 인터넷 뱅킹을 하거나 https 사이트에 접속할 때, 우리는 모두 이 PKI라는 거대한 사회적 약속 위에서 안전하게 통신하고 있는 것입니다</p>
<h2 id="이론과-실무의-연결고리--코드와-브라우저에서-마주친-인증서" style="position:relative;"><a href="#%EC%9D%B4%EB%A1%A0%EA%B3%BC-%EC%8B%A4%EB%AC%B4%EC%9D%98-%EC%97%B0%EA%B2%B0%EA%B3%A0%EB%A6%AC--%EC%BD%94%EB%93%9C%EC%99%80-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C" aria-label="이론과 실무의 연결고리  코드와 브라우저에서 마주친 인증서 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이론과 실무의 연결고리 : 코드와 브라우저에서 마주친 인증서</h2>
<p>개념은 이제 알겠습니다. 그렇다면 이 '인증서'라는 것을 우리는 실제 어디서 마주치게 될까요? 제 경험을 돌이켜보니 크게 두 군데였습니다.</p>
<p>바로 서버 간 통신 코드와 매일 사용하는 웹 브라우저입니다.</p>
<h3 id="서버-간-통신-코드로-만나는-인증서의-실체" style="position:relative;"><a href="#%EC%84%9C%EB%B2%84-%EA%B0%84-%ED%86%B5%EC%8B%A0-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%8A%94-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%8B%A4%EC%B2%B4" aria-label="서버 간 통신 코드로 만나는 인증서의 실체 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>서버 간 통신: 코드로 만나는 인증서의 실체</h3>
<p>모바일 결제 솔루션을 개발하다 보면, 저희 서버는 카드사나 글로벌 결제 네트워크사와 같은 외부 시스템과 매우 민감한 정보를 주고받아야 합니다.</p>
<p>이때 안전한 통신 채널을 만들기 위해 바로 이 인증서가 사용됩니다.</p>
<p>파트너사로부터 전달받은 PEM(텍스트) 형식의 인증서 데이터를 코드에서 다뤘던 기억이 생생합니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">PublicKey</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>cert<span class="token punctuation">.</span></span><span class="token class-name">X509Certificate</span></span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token comment">// 파트너사로부터 받은 PEM 형식의 인증서 문자열</span>
<span class="token class-name">String</span> partnerCertificatePemData <span class="token operator">=</span> <span class="token string">"-----BEGIN CERTIFICATE-----\nMIIC... \n-----END CERTIFICATE-----"</span><span class="token punctuation">;</span>

<span class="token comment">// 이 PEM 데이터를 프로그램이 이해할 수 있는 객체로 변환합니다.</span>
<span class="token comment">// (실제 코드는 라이브러리나 유틸 클래스를 사용하므로, 개념을 보여주기 위한 가상 코드입니다.)</span>
<span class="token class-name">X509Certificate</span> partnerCertificate <span class="token operator">=</span> cryptoProvider<span class="token punctuation">.</span><span class="token function">getCertificateFromPem</span><span class="token punctuation">(</span>partnerCertificatePemData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 이제 인증서 객체에서 가장 중요한 '공개키'를 추출할 수 있습니다.</span>
<span class="token class-name">PublicKey</span> partnerPublicKey <span class="token operator">=</span> partnerCertificate<span class="token punctuation">.</span><span class="token function">getPublicKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 이 공개키를 사용해서 파트너사에게 보낼 데이터를 안전하게 암호화합니다.</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encryptedData <span class="token operator">=</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>sensitiveData<span class="token punctuation">,</span> partnerPublicKey<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>여기서 X.509가 바로 국제 표준 디지털 인증서 형식이었고, 자바의 X509Certificate 클래스가 코드 레벨에서 다루는 인증서의 실체였던 것입니다.</p>
<p>처음에는 그저 암호화에 필요한 키를 가져오는 과정이라고만 생각했는데, 이제는 이 코드가 PKI라는 거대한 신뢰 시스템 위에서 동작하고 있다는 것을 알게 되었습니다.</p>
<h3 id="웹-브라우저-매일-경험하는-신뢰의-사슬" style="position:relative;"><a href="#%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A7%A4%EC%9D%BC-%EA%B2%BD%ED%97%98%ED%95%98%EB%8A%94-%EC%8B%A0%EB%A2%B0%EC%9D%98-%EC%82%AC%EC%8A%AC" aria-label="웹 브라우저 매일 경험하는 신뢰의 사슬 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>웹 브라우저: 매일 경험하는 '신뢰의 사슬'</h3>
<p>인증서는 서버 개발자만 만나는 것이 아닙니다. 우리는 매일 웹 브라우저를 통해 인증서의 덕을 보고 있습니다. 주소창에 뜨는 자물쇠 아이콘이 바로 그 증거입니다.</p>
<p>호기심이 생겨 브라우저의 자물쇠 아이콘을 눌러 구글의 인증서 정보를 직접 열어봤습니다.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/0f9432e974cd74f5cd80f28a0bd5d2af/e4ddf/image.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 119.79166666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAABkElEQVR42qWVia6CUAxE7///ohgVF0BcccG95kxSYnxGL7wmI+GKw7Sd1rDdbq3f79toNLKyLG06nVqSJLpfr9dGPB4P+xWXy8Wu16uFw+Fgq9XKNpuNSIbDoe53u53VdW33+91ut9tPQCbCqqosz3MRulKIeIi3ns/nKPizgZRJcz6fSzqK/EuubRFOp5Nqh8rZbCaimBQ/QYTkfTwebTwe66Br0LhGIY1ZLBY2mUyE5XKps/1+Hw1vYnAySKhllmWyiz/UBohTl1GFVVx61xrKNuQNGQ0pikKHbYkQgTCgppD2YDDQtUszCHyMMBES+JE3uBdjxu01vLnBrYJ1qCU+7BKI0KTQasjodK/Xkx8BZuect8ZCXYYQYBtmGdvQIKzjL4uFFHrK+IiUvaZtg25LoROgxm3zL0JfjK9e8o3TxpPN+qJW1I0fQ/S+UDmPXV2aFGRCmKapzM0VUE/fk63XF3jfvI7Ymjbri49vU8F33/CH0BW+1uFTbT6BDJhfhoJZbmzTFRDyp8aEUXMW7BONZVHGdrRVzQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <picture>
          <source
              srcset="/static/0f9432e974cd74f5cd80f28a0bd5d2af/a59e9/image.webp 192w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/0ca9f/image.webp 384w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/dc9b9/image.webp 768w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/89e1d/image.webp 1082w"
              sizes="(max-width: 768px) 100vw, 768px"
              type="image/webp"
            />
          <source
            srcset="/static/0f9432e974cd74f5cd80f28a0bd5d2af/3b721/image.png 192w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/66595/image.png 384w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/fe486/image.png 768w,
/static/0f9432e974cd74f5cd80f28a0bd5d2af/e4ddf/image.png 1082w"
            sizes="(max-width: 768px) 100vw, 768px"
            type="image/png"
          />
          <img
            class="gatsby-resp-image-image"
            src="/static/0f9432e974cd74f5cd80f28a0bd5d2af/fe486/image.png"
            alt="alt text"
            title=""
            loading="lazy"
            decoding="async"
            style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
          />
        </picture>
  </a>
    </span></p>
<p>거기에는 '인증서 경로' 또는 '인증서 계층'이라는 흥미로운 정보가 있었습니다.</p>
<ul>
<li>인증서 계층
<ul>
<li>GTS Root R4 (최상위 인증 기관)</li>
<li>WE2 (중간 인증 기관)</li>
<li>*.google.com (구글 서버 인증서)</li>
</ul>
</li>
</ul>
<p>이것이 바로 최상위 CA → 중간 CA → 서버로 이어지는 <strong>'신뢰의 사슬(Chain of Trust)'</strong> 이었습니다. 브라우저의 역할은 이렇습니다.</p>
<ol>
<li>구글 서버가 보낸 *.google.com 인증서의 서명을 확인합니다. "이건 WE2가 서명했네."</li>
<li>WE2 인증서의 서명을 확인합니다. "이건 GTS Root R4가 서명했구나."</li>
<li>마지막으로, 자신의 '신뢰 저장소(Trust Store)'를 뒤져봅니다. "내 컴퓨터에 GTS Root R4가 신뢰할 수 있는 기관으로 등록되어 있나?"</li>
<li>등록이 되어 있다면, 모든 서명이 유효하다고 판단하고 자물쇠 아이콘을 띄워주는 것입니다.</li>
</ol>
<h3 id="gts-root-r4를-어떻게-알고-신뢰하는-걸까" style="position:relative;"><a href="#gts-root-r4%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EC%8B%A0%EB%A2%B0%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C" aria-label="gts root r4를 어떻게 알고 신뢰하는 걸까 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GTS Root R4를 어떻게 알고 신뢰하는 걸까?</h3>
<p>이것이 바로 PKI 신뢰 모델의 가장 중요한 핵심, <strong>'신뢰의 앵커(Trust Anchor)'</strong> 개념입니다. <br/>신뢰는 무한히 거슬러 올라갈 수 없기에, 모든 신뢰가 시작되는 절대적인 출발점이 필요합니다.</p>
<p>최상위 인증 기관(Root CA)의 인증서가 바로 이 앵커 역할을 합니다.
<br/> 이 인증서들은 우리가 인터넷에서 다운로드하는 것이 아니라, Windows나 macOS, Android 같은 운영체제를 설치할 때 이미 함께 설치됩니다.</p>
<p>마이크로소프트, 애플, 구글과 같은 OS 제조사들은 매우 엄격한 보안 감사를 통과한 신뢰할 수 있는 CA들의 목록을 만들어, 이들의 인증서를 OS에 미리 포함시켜 배포합니다.</p>
<p>이 특별한 저장 공간을 <strong>'루트 스토어(Root Store)'</strong> 라고 부릅니다.</p>
<p>결국 브라우저가 하는 검증은, 정부가 위조 방지된 공식 인감을 미리 지정해두면 우리가 그 인감만 보고 서류를 신뢰하는 것과 같습니다.
`브라우저는 루트 스토어에 등록된 CA라면 '묻지도 따지지도 않고' 신뢰하며, 이로부터 이어진 모든 신뢰의 사슬을 검증하는 것입니다.</p>
<p>결국 서버 코드에서 다루던 X509Certificate와 브라우저의 자물쇠 아이콘은, 표현 방식만 다를 뿐 <code class="language-text">PKI</code> 라는 동일한 원리 위에서 우리의 통신을 안전하게 지켜주고 있었던 것입니다.</p>
<h2 id="암호화-데이터의-구조와-형식-pkcs와-pem" style="position:relative;"><a href="#%EC%95%94%ED%98%B8%ED%99%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%98%95%EC%8B%9D-pkcs%EC%99%80-pem" aria-label="암호화 데이터의 구조와 형식 pkcs와 pem permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>암호화 데이터의 구조와 형식: PKCS와 PEM</h2>
<p>인증서의 원리를 이해하고 나니, 또 다른 질문이 생겼습니다. "인증서나 개인키 같은 민감한 정보는 컴퓨터에서 정확히 어떤 모습으로 저장되고, 시스템 간에 어떻게 교환될까?"</p>
<p>이 질문에 대한 답이 바로 PKCS와 PEM에 있었습니다. 이 둘은 각각 데이터의 '구조' 와 '형식' 을 정의하는 중요한 약속입니다</p>
<h3 id="pem-privacy-enhanced-mail" style="position:relative;"><a href="#pem-privacy-enhanced-mail" aria-label="pem privacy enhanced mail permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PEM (Privacy Enhanced Mail)</h3>
<p>PEM은 우리가 가장 흔하게 마주치는 파일 형식입니다. 원래는 이름처럼 이메일 보안을 위해 만들어졌지만, 지금은 암호화 관련 데이터를 저장하고 전송하는 표준적인 텍스트 형식으로 널리 사용됩니다.</p>
<ul>
<li>역할: 바이너리(0과 1로 이루어진) 형태의 인증서나 키 데이터를, 어떤 시스템에서도 안전하게 복사하고 붙여넣을 수 있는 <strong>텍스트 문자열로 변환(인코딩)</strong> 하는 역할을 합니다.</li>
<li>구조와 특징:
<ul>
<li>인증서나 키 같은 암호화 데이터의 원본 바이너리 형식은 보통 <strong><code class="language-text">DER(Distinguished Encoding Rules)</code></strong> 라는 표준에 따라 인코딩됩니다. DER은 데이터를 표현하는 하나의 바이너리 형식 규칙입니다.</li>
<li>PEM은 바로 이 <strong>DER 형식의 바이너리 데이터</strong>를 <code class="language-text">Base64</code> 방식으로 인코딩하여 텍스트로 변환한 것입니다. 기술적으로 <strong>"PEM = Base64(DER)"</strong> 이라고 이해할 수 있습니다.</li>
<li>그리고 이 텍스트 데이터의 시작과 끝을 -----BEGIN CERTIFICATE----- 와 -----END CERTIFICATE----- 같은 머리말과 꼬리말로 감싸, 내용물이 무엇인지 명확하게 알려줍니다.</li>
</ul>
</li>
</ul>
<p>결론적으로 PEM은, 암호화 데이터를 텍스트 기반의 환경(설정 파일, API 요청 본문 등)에서 쉽게 다루기 위한 '포장 형식' 입니다.</p>
<h3 id="pkcs-public-key-cryptography-standards" style="position:relative;"><a href="#pkcs-public-key-cryptography-standards" aria-label="pkcs public key cryptography standards permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PKCS (Public-Key Cryptography Standards)</h3>
<p>그렇다면 PEM 파일 안에 담기는 데이터의 내용물은 어떤 규칙으로 만들어질까요? 그 규칙을 정의한 것이 바로 PKCS입니다.</p>
<p>PKCS는 RSA Security 사에서 만든 공개키 암호 기술에 대한 산업 표준 규약 모음입니다.<br/> 즉, 파일 형식이 아니라 데이터의 논리적인 구조를 정의한 '설계도' 입니다</p>
<p>여러 PKCS 표준 중, 실무에서 자주 보이는 두 가지는 다음과 같습니다.</p>
<ul>
<li>PKCS#8:</li>
</ul>
<p><strong>개인키(Private Key)의 구조를 정의하는 표준</strong> 입니다. 이 표준에 따르면, 개인키 정보에는 실제 키 데이터뿐만 아니라 이 키가 어떤 알고리즘(예: RSA, ECC)을 사용하는지에 대한 정보도 함께 포함되어야 합니다.
<br/>우리가 -----BEGIN PRIVATE KEY----- 라는 헤더를 가진 PEM 파일을 본다면, 그 안의 내용은 이 PKCS#8 표준에 따라 구성되어 있을 가능성이 높습니다.</p>
<ul>
<li>PKCS#12:</li>
</ul>
<p>개인키와 그에 맞는 인증서, 그리고 상위 CA 인증서 체인까지 하나로 묶는 방법을 정의하는 표준입니다. <br/>보통 암호로 보호되는 바이너리 파일(.p12 또는 .pfx 확장자) 형태로 만들어지며, '디지털 금고'처럼 관련된 모든 정보를 안전하게 보관하고 한 번에 전달하는 데 사용됩니다.</p>
<p>PEM은 데이터를 <strong>어떻게 포장해서 보여줄지(파일 형식)</strong> 를 정의하고, PKCS는 그 포장 안에 담길 <strong>데이터의 내용물을 어떻게 구성할지(구조 표준)</strong> 를 정의합니다.</p>
<h3 id="실무에서-마주친-두-가지-방식-pem과-pkcs12" style="position:relative;"><a href="#%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%9C-%EB%91%90-%EA%B0%80%EC%A7%80-%EB%B0%A9%EC%8B%9D-pem%EA%B3%BC-pkcs12" aria-label="실무에서 마주친 두 가지 방식 pem과 pkcs12 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>실무에서 마주친 두 가지 방식: PEM과 PKCS#12</h3>
<p>이론을 알고 나니, 과거에 작성했던 코드가 새롭게 보이기 시작했습니다. 흥미롭게도 저희 프로젝트에서는 통신하는 대상에 따라 두 가지 방식을 모두 사용하고 있었습니다.</p>
<h4 id="visa와의-통신-pem-형식-활용" style="position:relative;"><a href="#visa%EC%99%80%EC%9D%98-%ED%86%B5%EC%8B%A0-pem-%ED%98%95%EC%8B%9D-%ED%99%9C%EC%9A%A9" aria-label="visa와의 통신 pem 형식 활용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Visa와의 통신: PEM 형식 활용</h4>
<p>Visa와 통신하며 데이터를 암호화할 때는, properties 파일에 저장된 PEM 형식의 인증서 문자열을 읽어와 공개키를 추출했습니다</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token comment">// Visa의 암호화용 공개키가 담긴 PEM 형식의 문자열</span>
<span class="token class-name">String</span> visaEncryptionPublicKeyPemData <span class="token operator">=</span> <span class="token string">"..."</span><span class="token punctuation">;</span> <span class="token comment">// 설정 파일 등에서 읽어온 값</span>

<span class="token comment">// PEM 데이터에서 X.509 인증서 객체를 생성</span>
<span class="token class-name">X509Certificate</span> x509Certificate <span class="token operator">=</span> visaCrypto<span class="token punctuation">.</span><span class="token function">getCertificate</span><span class="token punctuation">(</span>visaEncryptionPublicKeyPemData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 인증서에서 최종적으로 암호화에 사용할 공개키를 추출</span>
visaEncryptPublicKey <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RSAPublicKey</span><span class="token punctuation">)</span> x509Certificate<span class="token punctuation">.</span><span class="token function">getPublicKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>이 방식은 텍스트 기반이라 설정 파일이나 클라우드 환경에 유연하게 통합할 수 있다는 장점이 있습니다.</p>
<p>⚠️ 예시에서는 코드의 가독성을 위해 문자열 변수로 표현했지만, 실제 운영 환경(Production)에서는 보안을 위해 PEM 데이터나 비밀번호 같은 민감 정보를 application.properties 파일에 직접 저장하는 것은 매우 위험합니다. 소스 코드에 민감 정보가 그대로 노출될 수 있기 때문입니다.</p>
<br/>
<h4 id="mastercard와의-통신-pkcs12-형식-활용" style="position:relative;"><a href="#mastercard%EC%99%80%EC%9D%98-%ED%86%B5%EC%8B%A0-pkcs12-%ED%98%95%EC%8B%9D-%ED%99%9C%EC%9A%A9" aria-label="mastercard와의 통신 pkcs12 형식 활용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mastercard와의 통신: PKCS#12 형식 활용</h4>
<p>반면 Mastercard와 통신할 때는, 암호화된 .p12 파일을 직접 로드해서 개인키를 가져왔습니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token comment">// .p12 파일을 다루기 위한 자바의 KeyStore 객체</span>
<span class="token class-name">KeyStore</span> pkcs12KeyStore <span class="token operator">=</span> <span class="token class-name">KeyStore</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"PKCS12"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 파일 경로와 비밀번호를 이용해 .p12 파일 로드</span>
<span class="token comment">// (파일 경로와 비밀번호 역시 외부 Secret 저장소에서 가져오는 것이 안전합니다.)</span>
pkcs12KeyStore<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span>pkcs12KeyFilePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> signingKeyPassword<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// KeyStore에서 지정된 별칭(alias)과 비밀번호로 개인키를 추출</span>
clientEncryptionPrivateKey <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PrivateKey</span><span class="token punctuation">)</span> pkcs12KeyStore<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span>signingKeyAlias<span class="token punctuation">,</span> signingKeyPassword<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>PKCS#12 방식은 필요한 모든 정보(개인키, 인증서 등)를 하나의 암호화된 파일로 안전하게 관리하고 전달할 수 있다는 점에서 이점이 있습니다.</p>
<p>이처럼 어떤 방식이 절대적으로 좋다기보다는, 각 시스템의 정책과 지향점에 따라 다른 표준을 채택한다는 점이 매우 흥미로웠습니다.</p>
<p>결국 두 방식 모두 PKI라는 큰 틀 안에서 안전한 통신을 구현하기 위한 서로 다른 접근법인 셈입니다.</p>
<h2 id="맺으며" style="position:relative;"><a href="#%EB%A7%BA%EC%9C%BC%EB%A9%B0" aria-label="맺으며 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>맺으며</h2>
<p>우리가 만드는 결제 솔루션의 핵심은 결국 '신뢰'입니다.
그리고 그 신뢰는 바로 이런 탄탄한 암호 기술 위에서 만들어진다는 것을 다시 한번 느끼며, 앞으로 더 책임감을 갖고 코드를 작성해야겠습니다.</p></div><style data-emotion="css hx9xpc">@media (max-width: 768px){.css-hx9xpc{padding:0 20px;}}</style><div class="css-hx9xpc e12j4d8y0"></div><style data-emotion="css fmunkh">.css-fmunkh{position:absolute;top:0;left:768px;height:100%;padding-left:4rem;}@media (max-width: 1400px){.css-fmunkh{display:none;}}</style><aside class="css-fmunkh ek4ynda1"><style data-emotion="css 1s5ilwz">.css-1s5ilwz{position:-webkit-sticky;position:sticky;top:6rem;width:240px;overflow:hidden;font-size:0.8rem;}.css-1s5ilwz p{margin:0;}.css-1s5ilwz a{display:block;padding:0.5rem;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;border-radius:4px;-webkit-transition:all 0.1s ease-out;transition:all 0.1s ease-out;}.css-1s5ilwz a:hover{background-color:#badcff;}.css-1s5ilwz ul:first-child{border-left:none;}.css-1s5ilwz ul{margin-left:0.5rem;padding:0 0.5rem;list-style:none;border-left:2px solid #e2e5e6;}</style><nav class="css-1s5ilwz ek4ynda0"><ul>
<li>
<p><a href="#%EC%9D%B4-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EC%A0%95%EB%A7%90-%EB%AF%BF%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C">이 공개키, 정말 믿을 수 있을까?</a></p>
</li>
<li>
<p><a href="#%EC%8B%A0%EB%A2%B0%EC%9D%98-%EC%9D%B4%EB%A6%84%ED%91%9C-%EB%94%94%EC%A7%80%ED%84%B8-%EC%9D%B8%EC%A6%9D%EC%84%9C-x509-certificate">신뢰의 이름표, 디지털 인증서 (X.509 Certificate)</a></p>
</li>
<li>
<p><a href="#%EA%B7%B8%EB%9F%BC-pki%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C">그럼 PKI는 무엇일까?</a></p>
</li>
<li>
<p><a href="#%EC%9D%B4%EB%A1%A0%EA%B3%BC-%EC%8B%A4%EB%AC%B4%EC%9D%98-%EC%97%B0%EA%B2%B0%EA%B3%A0%EB%A6%AC--%EC%BD%94%EB%93%9C%EC%99%80-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C">이론과 실무의 연결고리 : 코드와 브라우저에서 마주친 인증서</a></p>
<ul>
<li><a href="#%EC%84%9C%EB%B2%84-%EA%B0%84-%ED%86%B5%EC%8B%A0-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%8A%94-%EC%9D%B8%EC%A6%9D%EC%84%9C%EC%9D%98-%EC%8B%A4%EC%B2%B4">서버 간 통신: 코드로 만나는 인증서의 실체</a></li>
<li><a href="#%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A7%A4%EC%9D%BC-%EA%B2%BD%ED%97%98%ED%95%98%EB%8A%94-%EC%8B%A0%EB%A2%B0%EC%9D%98-%EC%82%AC%EC%8A%AC">웹 브라우저: 매일 경험하는 '신뢰의 사슬'</a></li>
<li><a href="#gts-root-r4%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EC%8B%A0%EB%A2%B0%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C">GTS Root R4를 어떻게 알고 신뢰하는 걸까?</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%95%94%ED%98%B8%ED%99%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%98%95%EC%8B%9D-pkcs%EC%99%80-pem">암호화 데이터의 구조와 형식: PKCS와 PEM</a></p>
<ul>
<li>
<p><a href="#pem-privacy-enhanced-mail">PEM (Privacy Enhanced Mail)</a></p>
</li>
<li>
<p><a href="#pkcs-public-key-cryptography-standards">PKCS (Public-Key Cryptography Standards)</a></p>
</li>
<li>
<p><a href="#%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%9C-%EB%91%90-%EA%B0%80%EC%A7%80-%EB%B0%A9%EC%8B%9D-pem%EA%B3%BC-pkcs12">실무에서 마주친 두 가지 방식: PEM과 PKCS#12</a></p>
<ul>
<li><a href="#visa%EC%99%80%EC%9D%98-%ED%86%B5%EC%8B%A0-pem-%ED%98%95%EC%8B%9D-%ED%99%9C%EC%9A%A9">Visa와의 통신: PEM 형식 활용</a></li>
<li><a href="#mastercard%EC%99%80%EC%9D%98-%ED%86%B5%EC%8B%A0-pkcs12-%ED%98%95%EC%8B%9D-%ED%99%9C%EC%9A%A9">Mastercard와의 통신: PKCS#12 형식 활용</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%A7%BA%EC%9C%BC%EB%A9%B0">맺으며</a></p>
</li>
</ul></nav></aside></div><style data-emotion="css 3xgn3f">.css-3xgn3f{display:grid;place-items:center;margin-top:auto;padding:50px 0;font-size:15px;color:#aaa;font-weight:bold;text-align:center;line-height:1.5;background-color:#f0f0f0;}@media (max-width: 768px){.css-3xgn3f{font-size:13px;}}</style><div class="css-3xgn3f ehmnl591"><br/>© <!-- -->2025<!-- --> 박건희<style data-emotion="css 1tmvi1x">.css-1tmvi1x{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:5px;font-size:25px;}.css-1tmvi1x>a{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:inherit;}@media (max-width: 768px){.css-1tmvi1x{font-size:20px;}}</style><div class="css-1tmvi1x ehmnl590"><a href="https://github.com/connieya" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></a><a href="https://www.linkedin.com/in/%EA%B1%B4%ED%9D%AC-%EB%B0%95-6ab959238/" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></a></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/pki-and-certificates-explained/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-2a6f470a6ad9d828a849.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-8535dbf06a13c1090bd2.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-7226e26e24a45d3f8ba1.js\"],\"component---src-templates-post-template-tsx\":[\"/component---src-templates-post-template-tsx-767855da760b602a3e98.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="a5545b024bf82e8f12e2";</script><script src="/webpack-runtime-34793d79c4ff3bd9a082.js" async></script><script src="/framework-a02ced70e77b2a7c030d.js" async></script><script src="/app-2a6f470a6ad9d828a849.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>