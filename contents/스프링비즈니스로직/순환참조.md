---
date: '2023-09-20'
title: 'Dependency Injection 시 순환 참조
'
categories: ['Spring']
summary: 'Spring 32'
thumbnail: ''
---

## 발단

서비스간 의존성 주입을 함

예)

```java
@Service
@RequiredArgsConstructor
public class TaskService {

    private final PlanService planService;

    /// ... 기타 메서드
}
```

SchedulerService 에서 PlanService 를 의존함

여기서 발생할 수 있는 문제는??

### 문제

**순환 의존성 문제가 발생 할 수 있음**

순환 의존성이란 ?

> A 서비스가 B 서비스를 주입하고 B 서비스가 A 서비스를 다시 주입하는 경우 순환 의존성이 발생한다.
> 이는 런타임 에러를 일으킬 수 있으므로 주의가 필요하다.

위의 코드에서는 TaskService => PlanService 를 주입하기 때문에
문제가 발생하지 않았지만
만약에 PlanService => TaskService 주입한다면??

```java
@Service
@RequiredArgsConstructor
public class PlanService {
    private final TaskService taskService;

    // 기타 메서드
}
```

애플리케이션을 실행 했을 때 컴파일 에러가 발생한다.

![img.png](img.png)

![img_1.png](img_1.png)

응 ?? 런타임 에러가 아니고 컴파일 에러??

여기서 의존성 주입을 하는 방식에 따라 **런타임 에러**가 날수도 있고 **컴파일 에러**가 발생할 수 있다.

위의 코드 방식은 생성자 주입을 통해 의존성을 주입 하였다.

그래서 순환 참조가 발생 했을 때 컴파일 에러가 발생하였다.

만약 @Autowired 를 통한 필드 주입 방식을 한다면?

```java
@Service
public class TaskService {

    @Autowired
    private PlanService planService;

    /// ... 기타 메서드
}
```

```java
@Service

public class TaskService {
    @Autowired
    private PlanService planService;

    // 기타 메서드..
}
```

컴파일 에러가 발생하지 않고, 런타임 에러가 발생한다.

### 생성자 주입 vs 필드 주입

<br/>

#### 생성자 주입

- 의존성을 클래스의 생성자를 통해 주입하는 방식
- 순환 참조 문제가 발생할 가능성이 낮아진다.
- 객체 생성 시점에 의존성을 주입하기 때문이다.
- 만약 순환 참조가 발생하면 컴파일 오류나 런타임 오류로 쉽게 감지 할 수 있다.
- 대부분의 의존성 주입 프레임워크와 컨테이너에서 생성자 주입을 권장하고 지원한다.

#### 필드 주입

- 의존성을 클래스의 멤버 변수로 직접 주입하는 방식이다.
- 순환 참조 문제를 발생시킬 가능성이 높아질 수 있다.
- 필드 주입을 통해 객체 생성 후에 의존성이 주입되므로 순환 참조가 발생하더라도 런타임에 오류가 감지된다.
- 일반적으로 생성자 주입보다 순환 참조 문제를 발생시키기 쉽기 때문에 권장되지 않는다.
