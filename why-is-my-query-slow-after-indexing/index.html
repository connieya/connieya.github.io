<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.14.5"/><meta data-react-helmet="true" name="description"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" http-equiv="Content-Type" content="text/html;charset=UTF-8"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:title" content="인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) "/><meta data-react-helmet="true" property="og:description"/><meta data-react-helmet="true" property="og:image"/><meta data-react-helmet="true" property="og:url"/><meta data-react-helmet="true" property="og:site_name" content="인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) "/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) "/><meta data-react-helmet="true" name="twitter:description"/><meta data-react-helmet="true" name="twitter:image"/><meta data-react-helmet="true" name="twitter:site" content="@사용자이름"/><meta data-react-helmet="true" name="twitter:creator" content="@사용자이름"/><meta data-react-helmet="true" name="google-site-verification" content="웹 마스터 도구가 제공하는 Meta 태그"/><meta data-react-helmet="true" name="naver-site-verification" content="웹 마스터 도구가 제공하는 Meta 태그"/><style data-href="/styles.9e907bc32054b7771552.css" data-identity="gatsby-global-css">code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) </title><link rel="sitemap" type="application/xml" href="/sitemap-index.xml"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="canonical" href="https://connieya.github.io/why-is-my-query-slow-after-indexing/" data-baseprotocol="https:" data-basehost="connieya.github.io"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 11pfcjj">.css-11pfcjj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;}</style><div class="css-11pfcjj esjg9ma0"><style data-emotion="css 123clne">.css-123clne{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:7rem;}</style><div class="css-123clne e1o8p83g6"><style data-emotion="css j1kgmw">.css-j1kgmw{width:100%;max-width:768px;margin:0 auto;padding:0 1rem;}@media (max-width: 768px){.css-j1kgmw{padding:0 0.75rem;}}</style><div class="css-j1kgmw e1o8p83g5"><style data-emotion="css 15umcqw">.css-15umcqw{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:2rem;}</style><div class="css-15umcqw e1o8p83g4"><style data-emotion="css 6ybclw">.css-6ybclw{-webkit-text-decoration:none;text-decoration:none;color:inherit;-webkit-transition:opacity 0.2s ease;transition:opacity 0.2s ease;}.css-6ybclw:hover{opacity:0.8;}</style><a class="css-6ybclw e1o8p83g3" href="/"><style data-emotion="css vqqu6f">.css-vqqu6f{font-size:1.3rem;font-weight:bold;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}</style><span class="css-vqqu6f e1o8p83g1">박건희</span></a><a class="css-6ybclw e1o8p83g2" href="/blog/"><style data-emotion="css 11g2wj9">.css-11g2wj9{font-size:1.1rem;font-weight:400;color:#666;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}</style><span class="css-11g2wj9 e1o8p83g0">개발</span></a><a class="css-6ybclw e1o8p83g2" href="/guestbook/"><span class="css-11g2wj9 e1o8p83g0">방명록</span></a></div></div></div><style data-emotion="css-global 4cqo99">*{padding:0;margin:0;box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}html,body,#___gatsby{height:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji';}a,a:hover{color:inherit;-webkit-text-decoration:none;text-decoration:none;cursor:pointer;}</style><style data-emotion="css 11k3q87">.css-11k3q87{position:relative;width:100%;max-width:768px;margin:0 auto;}</style><div class="css-11k3q87 e17f455w0"><style data-emotion="css jwelnu">.css-jwelnu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:2.5rem 1rem 2rem;max-width:768px;margin:0 auto;}@media (max-width: 768px){.css-jwelnu{padding:2rem 0.75rem 1.5rem;}}</style><div class="css-jwelnu ehbuenk5"><style data-emotion="css gjsprg">.css-gjsprg{word-break:keep-all;line-height:1.3;font-size:1.9rem;margin-bottom:1.3rem;}@media (max-width: 768px){.css-gjsprg{font-size:1.8rem;margin-bottom:0.8rem;}}</style><h1 class="css-gjsprg ehbuenk4">인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) </h1><style data-emotion="css 1r9pax5">.css-1r9pax5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;color:#757575;font-size:0.9rem;}@media (max-width: 768px){.css-1r9pax5{-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;}}</style><div class="css-1r9pax5 ehbuenk3"><style data-emotion="css 1bmnxg7">.css-1bmnxg7{white-space:nowrap;}</style><div class="css-1bmnxg7 ehbuenk2">2025-08-15<style data-emotion="css uaob3j">.css-uaob3j{margin-left:0.5rem;}</style><span class="css-uaob3j ehbuenk1">약 <!-- -->11<!-- -->분</span></div></div></div><style data-emotion="css pqebd0">.css-pqebd0{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;margin:0 auto;padding:1.5rem 1rem;line-height:1.75;word-break:break-all;}@media (max-width: 768px){.css-pqebd0{padding:1.5rem 0.75rem;}}.css-pqebd0 h1,.css-pqebd0 h2,.css-pqebd0 h3{margin-bottom:1.5rem;font-weight:700;}.css-pqebd0 h1{padding-left:0.2rem;font-size:2rem;border-bottom:1px solid #e2e5e6;}.css-pqebd0 h2{font-size:1.75rem;border-bottom:1px solid #e2e5e6;}.css-pqebd0 h3{font-size:1.25rem;}.css-pqebd0 *+h1,.css-pqebd0 *+h2,.css-pqebd0 *+h3{margin-top:2rem;margin-bottom:0.5rem;}.css-pqebd0 hr+h1,.css-pqebd0 hr+h2,.css-pqebd0 hr+h3{margin-top:0;}.css-pqebd0 blockquote{margin:30px 0;padding:0 1rem;color:#757575;font-weight:800;border-left:2px solid #e2e5e6;}.css-pqebd0 ol,.css-pqebd0 ul{margin-top:0rem;margin-bottom:0rem;margin-left:1rem;padding:0.5rem 0;}.css-pqebd0 li{font-weight:300;}.css-pqebd0 hr{margin:100px 0;border:1px solid #000;}.css-pqebd0 a{color:#0E68C8;}.css-pqebd0 p{margin:0;padding:0.5rem 0;font-weight:300;}.css-pqebd0 img{margin:1rem 0;max-width:100%;height:auto;display:block;margin-left:auto;margin-right:auto;}.css-pqebd0 pre[class*='language-'],.css-pqebd0 code[class*='language-']{color:#d4d4d4;font-size:13px;font-family:Menlo,Monaco,Consolas,'Andale Mono','Ubuntu Mono','Courier New',monospace;direction:ltr;white-space:pre;text-align:left;text-shadow:none;word-break:normal;word-spacing:normal;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;border-radius:0.5rem;}.css-pqebd0 pre[class*='language-']::selection,.css-pqebd0 code[class*='language-']::selection,.css-pqebd0 pre[class*='language-'] *::selection,.css-pqebd0 code[class*='language-'] *::selection{text-shadow:none;background:#264f78;}@media print{.css-pqebd0 pre[class*='language-'],.css-pqebd0 code[class*='language-']{text-shadow:none;}}.css-pqebd0 pre[class*='language-']{padding:1rem;overflow:auto;background:#1e1e1e;}.css-pqebd0:not(pre)>code[class*='language-']{padding:0.1em 0.3em;background:#1e1e1e;border-radius:0;border-radius:0.3em;}.css-pqebd0 .namespace{opacity:0.7;}.css-pqebd0 .token.doctype .token.doctype-tag{color:#569cd6;}.css-pqebd0 .token.doctype .token.name{color:#9cdcfe;}.css-pqebd0 .token.comment,.css-pqebd0 .token.prolog{color:#6a9955;}.css-pqebd0 .token.punctuation,.css-pqebd0 .language-html .language-css .token.punctuation,.css-pqebd0 .language-html .language-javascript .token.punctuation{color:#d4d4d4;}.css-pqebd0 .token.property,.css-pqebd0 .token.tag,.css-pqebd0 .token.boolean,.css-pqebd0 .token.number,.css-pqebd0 .token.constant,.css-pqebd0 .token.symbol,.css-pqebd0 .token.inserted,.css-pqebd0 .token.unit{color:#b5cea8;}.css-pqebd0 .token.selector,.css-pqebd0 .token.attr-name,.css-pqebd0 .token.string,.css-pqebd0 .token.char,.css-pqebd0 .token.builtin,.css-pqebd0 .token.deleted{color:#ce9178;}.css-pqebd0 .language-css .token.string.url{-webkit-text-decoration:underline;text-decoration:underline;}.css-pqebd0 .token.operator,.css-pqebd0 .token.entity{color:#d4d4d4;}.css-pqebd0 .token.operator.arrow{color:#569cd6;}.css-pqebd0 .token.atrule{color:#ce9178;}.css-pqebd0 .token.atrule .token.rule{color:#c586c0;}.css-pqebd0 .token.atrule .token.url{color:#9cdcfe;}.css-pqebd0 .token.atrule .token.url .token.function{color:#dcdcaa;}.css-pqebd0 .token.atrule .token.url .token.punctuation{color:#d4d4d4;}.css-pqebd0 .token.keyword{color:#569cd6;}.css-pqebd0 .token.keyword.module,.css-pqebd0 .token.keyword.control-flow{color:#c586c0;}.css-pqebd0 .token.function,.css-pqebd0 .token.function .token.maybe-class-name{color:#dcdcaa;}.css-pqebd0 .token.regex{color:#d16969;}.css-pqebd0 .token.important{color:#569cd6;}.css-pqebd0 .token.italic{font-style:italic;}.css-pqebd0 .token.constant{color:#9cdcfe;}.css-pqebd0 .token.class-name,.css-pqebd0 .token.maybe-class-name{color:#4ec9b0;}.css-pqebd0 .token.console{color:#9cdcfe;}.css-pqebd0 .token.parameter{color:#9cdcfe;}.css-pqebd0 .token.interpolation{color:#9cdcfe;}.css-pqebd0 .token.punctuation.interpolation-punctuation{color:#569cd6;}.css-pqebd0 .token.boolean{color:#569cd6;}.css-pqebd0 .token.property,.css-pqebd0 .token.variable,.css-pqebd0 .token.imports .token.maybe-class-name,.css-pqebd0 .token.exports .token.maybe-class-name{color:#9cdcfe;}.css-pqebd0 .token.selector{color:#d7ba7d;}.css-pqebd0 .token.escape{color:#d7ba7d;}.css-pqebd0 .token.tag{color:#569cd6;}.css-pqebd0 .token.tag .token.punctuation{color:#808080;}.css-pqebd0 .token.cdata{color:#808080;}.css-pqebd0 .token.attr-name{color:#9cdcfe;}.css-pqebd0 .token.attr-value,.css-pqebd0 .token.attr-value .token.punctuation{color:#ce9178;}.css-pqebd0 .token.attr-value .token.punctuation.attr-equals{color:#d4d4d4;}.css-pqebd0 .token.entity{color:#569cd6;}.css-pqebd0 .token.namespace{color:#4ec9b0;}.css-pqebd0 pre[class*='language-javascript'],.css-pqebd0 code[class*='language-javascript'],.css-pqebd0 pre[class*='language-jsx'],.css-pqebd0 code[class*='language-jsx'],.css-pqebd0 pre[class*='language-typescript'],.css-pqebd0 code[class*='language-typescript'],.css-pqebd0 pre[class*='language-tsx'],.css-pqebd0 code[class*='language-tsx']{color:#9cdcfe;}.css-pqebd0 pre[class*='language-css'],.css-pqebd0 code[class*='language-css']{color:#ce9178;}.css-pqebd0 pre[class*='language-html'],.css-pqebd0 code[class*='language-html']{color:#d4d4d4;}.css-pqebd0 .language-regex .token.anchor{color:#dcdcaa;}.css-pqebd0 .language-html .token.punctuation{color:#808080;}.css-pqebd0 pre[class*='language-']>code[class*='language-']{position:relative;z-index:1;}.css-pqebd0 .line-highlight.line-highlight{z-index:0;background:#f7ebc6;box-shadow:inset 5px 0 0 #f7d87c;}.css-pqebd0 pre[class*='language-text'],.css-pqebd0 code[class*='language-text']{padding:0.25rem;color:#000000;background-color:#e2e5e6;}@media (max-width: 768px){.css-pqebd0 img{width:100%;}.css-pqebd0 pre[class*='language-']{width:100%;overflow-x:auto;}}</style><div class="css-pqebd0 e13plzdv0"><p>이커머스 서비스에서 가격, 최신순, 인기순으로 상품 목록을 보여주는 것은 지극히 평범하고도 필수적인 기능이다</p>
<p>개발 단계의 적은 데이터에서는 드러나지 않는 성능 병목을 확인하기 위해, 의미 있는 규모의 테스트 데이터(상품 50만, 좋아요 10만)를 채워 넣고 마지막 관문인 성능 테스트를 시작했다.</p>
<p>이때 가장 중요한 것은 정확한 병목 지점을 찾는 것이었다. 여러 사용자로 테스트하면 네트워크나 서버 경합 등 다른 변수가 섞일 수 있기에, 변인 통제를 위해 오직 가상 사용자 1명(1 VU)으로 1분간 API를 반복 호출하여 순수한 API 처리 성능의 베이스라인을 측정하기로 했다.</p>
<p>측정 결과 평균 응답 시간이 10초를 훌쩍 넘는 믿기 힘든 결과가 나왔다.</p>
<p><img src="/images/k6test.png" alt="alt text"></p>
<p>DB 클라이언트에서 직접 쿼리를 실행해 보았다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">5.38</span> sec<span class="token punctuation">)</span></code></pre></div>
<p>단 5개의 데이터를 가져오는 데 5초 이상이 소요되고 있었다.</p>
<p>문제의 원인을 찾기 위해 곧바로 쿼리 분석에 들어갔다.</p>
<h2 id="group-by가-order-by-인덱스를-막는-순간" style="position:relative;"><a href="#group-by%EA%B0%80-order-by-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EB%A7%89%EB%8A%94-%EC%88%9C%EA%B0%84" aria-label="group by가 order by 인덱스를 막는 순간 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GROUP BY가 ORDER BY 인덱스를 막는 순간</h2>
<p>가장 먼저 의심한 곳은 product_like 테이블과 JOIN하여 좋아요 수를 집계하는 GROUP BY 구문이었다.</p>
<p>처음 쿼리를 설계할 때는 여러 번 쿼리를 날리는 서브쿼리보다, 단일 쿼리로 모든 정보를 가져오는 JOIN 방식이 더 효율적일 것이라는 막연한 믿음이 있었다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    p<span class="token punctuation">.</span>id
     <span class="token punctuation">,</span>p<span class="token punctuation">.</span>price
     <span class="token punctuation">,</span>p<span class="token punctuation">.</span>name
     <span class="token punctuation">,</span>b<span class="token punctuation">.</span>name
     <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>pl<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token keyword">as</span> likeCount
     <span class="token punctuation">,</span> p<span class="token punctuation">.</span>released_at <span class="token keyword">FROM</span>
    product p
        <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> brand b <span class="token keyword">ON</span> b<span class="token punctuation">.</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>ref_brand_id
        <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span>  product_like pl <span class="token keyword">ON</span> p<span class="token punctuation">.</span>id <span class="token operator">=</span> pl<span class="token punctuation">.</span>ref_product_id
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
    p<span class="token punctuation">.</span>id
       <span class="token punctuation">,</span> p<span class="token punctuation">.</span>price
       <span class="token punctuation">,</span>p<span class="token punctuation">.</span>name
       <span class="token punctuation">,</span> b<span class="token punctuation">.</span>name
       <span class="token punctuation">,</span> p<span class="token punctuation">.</span>released_at
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>price <span class="token keyword">ASC</span>
    <span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div>
<p>EXPLAIN으로 실행 계획을 확인하자, 나의 믿음이 어떻게 잘못되었는지 명확하게 드러났다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> <span class="token keyword">key</span>                         <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra
<span class="token comment">---|-------------|-------|-------|-----------------------------|--------|---------------------------------------------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> <span class="token boolean">NULL</span>                        <span class="token operator">|</span> <span class="token number">497193</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref<span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                     <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token boolean">NULL</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> pl    <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> UKi88ydvxuyj9djsf1yaq18mdpb  <span class="token operator">|</span> <span class="token number">99822</span>  <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span><span class="token keyword">hash</span> <span class="token keyword">join</span><span class="token punctuation">)</span>
</code></pre></div>
<ul>
<li><strong>type: ALL</strong> : product 테이블을 풀 스캔하고 있다. 인덱스를 전혀 활용하지 못하고 50만 건의 데이터를 모두 읽고 있다는 의미다.</li>
<li><strong>Extra: Using temporary; Using filesort</strong> : 성능 저하의 주범이다. <code class="language-text">GROUP BY</code>와 <code class="language-text">ORDER BY</code>를 함께 처리하기 위해, 데이터베이스는 조인과 집계가 끝난 거대한 중간 결과물을 임시 테이블에 저장(<code class="language-text">Using temporary</code>)한 뒤, 이 임시 테이블을 다시 정렬(<code class="language-text">Using filesort</code>)하는 최악의 시나리오로 동작하고 있었다. LIMIT 5는 이 모든 비효율적인 작업이 끝난 후에야 적용된다.</li>
</ul>
<h2 id="왜-price-인덱스가-안-타지-group-by의-우선순위" style="position:relative;"><a href="#%EC%99%9C-price-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%EC%95%88-%ED%83%80%EC%A7%80-group-by%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84" aria-label="왜 price 인덱스가 안 타지 group by의 우선순위 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 price 인덱스가 안 타지? (GROUP BY의 우선순위)</h2>
<p>"풀 스캔과 filesort가 문제라면, 정렬 컬럼에 인덱스를 걸면 해결될 것이다."</p>
<p>가장 단순하고 명쾌한 해결책이라고 생각했다. <code class="language-text">ORDER BY</code>의 대상인 product 테이블 price 컬럼에 B-Tree 인덱스를 생성했다.</p>
<p>이제 옵티마이저가 당연히 이 인덱스를 타고 filesort를 건너뛸 것이라고 확신했다. 그리고 다시 쿼리를 실행했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">5.35</span> sec<span class="token punctuation">)</span></code></pre></div>
<p>결과는 처참했다. <code class="language-text">5.38초</code>가 <code class="language-text">5.35초</code> 가 된 것은 오차 범위일 뿐, 아무것도 해결되지 않았다. 당혹스러운 마음에 다시 실행 계획을 확인했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+-----------------------------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra                             <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+-----------------------------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token number">497349</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort   <span class="token operator">|</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div>
<p>변한 것이 아무것도 없었다. product 테이블은 여전히 type: ALL로 풀 스캔되고 있었고, Extra에는 Using filesort가 선명하게 남아있었다.</p>
<p>인덱스를 분명히 만들었는데, 왜 데이터베이스는 사용조차 하지 않는 걸까?</p>
<p>이유는 데이터베이스의 실행 순서에 있었다.</p>
<p>옵티마이저는 <code class="language-text">ORDER BY</code> 절을 처리하기 전에, <code class="language-text">GROUP BY</code> 절을 먼저 수행하여 likeCount를 계산해야 한다.</p>
<p>이 집계 연산은 테이블의 전체 데이터를 대상으로 할 수밖에 없으므로, 옵티마이저는 price 인덱스를 사용하여 5개만 미리 뽑아내는 최적화를 포기해버린다.</p>
<p>결국 옵티마이저는 다음과 같은 순서로 동작한다.</p>
<ol>
<li>50만 개 상품 전체를 <code class="language-text">JOIN</code>, <code class="language-text">GROUP BY</code> 하여 likeCount가 포함된 거대한 임시 테이블 생성</li>
<li>이 인덱스가 없는 임시 테이블을 price 기준으로 정렬</li>
<li>price 인덱스는 원본 테이블에만 존재할 뿐, 이 임시 테이블에는 없으므로 무용지물</li>
</ol>
<p>이 비효율적인 과정을 도식으로 표현하면 다음과 같다</p>
<h4 id="a-초기느린-경로--join--group-by--order-by" style="position:relative;"><a href="#a-%EC%B4%88%EA%B8%B0%EB%8A%90%EB%A6%B0-%EA%B2%BD%EB%A1%9C--join--group-by--order-by" aria-label="a 초기느린 경로  join  group by  order by permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A. 초기(느린) 경로 — JOIN + GROUP BY + ORDER BY</h4>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">product <span class="token punctuation">(</span><span class="token keyword">Full</span> scan: <span class="token number">50</span>만<span class="token punctuation">)</span>
   └─ <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> product_like
         └─ <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>임시 테이블 생성<span class="token punctuation">)</span>
               └─ <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token punctuation">(</span><span class="token keyword">Using</span> filesort<span class="token punctuation">)</span>
                     └─ <span class="token keyword">LIMIT</span> <span class="token number">5</span></code></pre></div>
<p>JOIN 자체의 성능 문제일까 싶어,</p>
<p>이번에는 product_like 테이블의 ref_product_id 컬럼에도 인덱스를 추가한 뒤
실행 계획을 확인 해보았다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+---------------------------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra                           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+---------------------------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token number">497349</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> pl    <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span>                     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+---------------------------------+</span></code></pre></div>
<p>product_like 테이블의 실행 계획이 type: index에서 type: ref로 개선되며 조인 자체는 빨라졌다.</p>
<p>하지만 가장 큰 문제인 product 테이블의 type: ALL과 Using filesort는 조금도 변하지 않았다.</p>
<p>쿼리 시간은 여전히 5초대에 머물렀다. GROUP BY 절은 ORDER BY 절보다 먼저 실행되어 테이블 전체를 대상으로 집계 연산을 수행해야 한다. 이 과정에서 생성되는 임시 테이블에는 price 인덱스가 없으므로, 결국 ORDER BY를 위한 인덱스 최적화는 원천적으로 불가능했다.</p>
<h2 id="먼저-줄이고-나중에-계산한다-서브쿼리--limit-전략" style="position:relative;"><a href="#%EB%A8%BC%EC%A0%80-%EC%A4%84%EC%9D%B4%EA%B3%A0-%EB%82%98%EC%A4%91%EC%97%90-%EA%B3%84%EC%82%B0%ED%95%9C%EB%8B%A4-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC--limit-%EC%A0%84%EB%9E%B5" aria-label="먼저 줄이고 나중에 계산한다 서브쿼리  limit 전략 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>먼저 줄이고 나중에 계산한다: 서브쿼리 + LIMIT 전략</h2>
<p>GROUP BY라는 거대한 벽 앞에서 인덱스가 무력해지는 것을 확인한 나는, 문제 해결의 방향을 완전히 틀어야 했다. 인덱스 튜닝이 아니라, 쿼리 구조 자체를 변경하기로 결심했다.</p>
<p>나는 GROUP BY를 제거하고, likeCount를 SELECT 절의 스칼라 서브쿼리로 가져오는 방식으로 쿼리를 수정했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token comment">-- 최적화된 쿼리 (스칼라 서브쿼리)</span>
<span class="token keyword">SELECT</span>
    p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>price<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> product_like pl <span class="token keyword">WHERE</span> pl<span class="token punctuation">.</span>ref_product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token keyword">as</span> likeCount<span class="token punctuation">,</span>
    p<span class="token punctuation">.</span>released_at
<span class="token keyword">FROM</span> product p
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> brand b <span class="token keyword">ON</span> b<span class="token punctuation">.</span>id <span class="token operator">=</span> p<span class="token punctuation">.</span>ref_brand_id
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>price <span class="token keyword">ASC</span>
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div>
<h3 id="구조-변경만-적용했을-때-절반의-성공" style="position:relative;"><a href="#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD%EB%A7%8C-%EC%A0%81%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EC%A0%88%EB%B0%98%EC%9D%98-%EC%84%B1%EA%B3%B5" aria-label="구조 변경만 적용했을 때 절반의 성공 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>구조 변경만 적용했을 때: 절반의 성공</h3>
<p>먼저, product 테이블의 모든 인덱스를 제거하고 순수하게 쿼리 구조 변경의 효과만 확인해 보았다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.63</span> sec<span class="token punctuation">)</span></code></pre></div>
<p><code class="language-text">5.38초</code>에 비하면 엄청난 발전이다. 8배 이상 빨라졌다. GROUP BY를 제거한 것만으로도 상당한 성능 개선이 이루어진 것이다.</p>
<p>하지만 <code class="language-text">0.63초</code> 역시 만족스러운 속도는 아니었다. EXPLAIN을 통해 그 이유를 파헤쳐 보았다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+----------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra          <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------+---------+----------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token number">497193</span> <span class="token operator">|</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>
<ul>
<li><code class="language-text">type: ALL</code> 및 <code class="language-text">Extra: Using filesort</code> : 여전히 product 테이블은 풀 스캔되고 있었고, filesort가 발생하고 있었다. price 인덱스가 없으니 당연한 결과다.</li>
<li>달라진 점: 이전과 달리, <code class="language-text">Using temporary</code>가 사라졌다. GROUP BY가 없어지면서 거대한 임시 테이블을 만들 필요가 없어졌고, filesort의 대상도 JOIN과 집계가 포함된 복잡한 결과가 아닌 product 테이블 자체로 단순화되었다.<br/> 이것이 <code class="language-text">5.38초</code>가 <code class="language-text">0.63초</code>로 줄어든 핵심 이유다.</li>
</ul>
<p>구조 변경은 temporary table이라는 가장 무거운 족쇄 하나를 풀어주었지만, filesort라는 족쇄는 여전히 남아있었다.</p>
<h3 id="구조-변경--인덱스-진정한-시너지의-발현" style="position:relative;"><a href="#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%8B%9C%EB%84%88%EC%A7%80%EC%9D%98-%EB%B0%9C%ED%98%84" aria-label="구조 변경  인덱스 진정한 시너지의 발현 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>구조 변경 + 인덱스: 진정한 시너지의 발현</h3>
<p>이제 이 새로운 쿼리 구조에 날개를 달아줄 차례다. product(price) 컬럼에 다시 인덱스를 생성했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.06</span> sec<span class="token punctuation">)</span></code></pre></div>
<p>결과는 경이로웠다. <code class="language-text">0.63초</code>가 <code class="language-text">0.06</code>초로, 다시 10배 이상 빨라졌다.</p>
<p>JOIN과 GROUP BY가 있던 시절과 비교하면 거의 90배에 가까운 성능 향상이다. EXPLAIN은 이 극적인 변화의 이유를 명확하게 보여주었다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------------+-------+-------+-----------+------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> <span class="token keyword">key</span>       <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+-------+-----------+------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> idx_price <span class="token operator">|</span>    <span class="token number">5</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>
<ul>
<li><strong><code class="language-text">type: index</code></strong>: <code class="language-text">ALL</code>이 <code class="language-text">index</code>로 바뀌었다. 이제 옵티마이저는 <code class="language-text">price</code> 인덱스를 보고 테이블 전체를 읽는 대신, 인덱스만 읽어서 처리한다.</li>
</ul>
<ul>
<li><strong><code class="language-text">rows: 5</code></strong>: 처리할 예상 행 수가 50만에서 단 5로 줄었다. <code class="language-text">ORDER BY</code>와 <code class="language-text">LIMIT</code>을 보고, 필요한 만큼만 읽으면 된다는 것을 완벽하게 인지한 것이다.</li>
<li><strong><code class="language-text">Extra: NULL</code></strong>: 마침내 <strong><code class="language-text">Using filesort</code>가 사라졌다.</strong> 인덱스 자체가 이미 <code class="language-text">price</code> 순으로 정렬되어 있으므로, 별도의 정렬 작업이 전혀 필요 없어진 것이다.</li>
</ul>
<p>이전의 <code class="language-text">JOIN</code>은 <strong>"선 계산, 후 정렬"</strong> 방식으로 50만 개 전체를 대상으로 무거운 작업을 했다면, 서브쿼리 방식은 <strong>"선 정렬 및 범위 축소, 후계산"</strong> 방식으로 동작했다.</p>
<p>즉, <code class="language-text">ORDER BY</code>와 <code class="language-text">LIMIT</code>으로 5개의 대상을 먼저 추려낸 뒤, 그 5개에 대해서만 서브쿼리를 실행하여 작업의 총량을 극적으로 줄인 것이다.</p>
<p><strong>좋은 쿼리 구조(서브쿼리)와 좋은 인덱스(<code class="language-text">price</code>)가 만났을 때 비로소 최적의 성능이 나온다는 것</strong>을 데이터로 증명한 순간이었다.</p>
<h4 id="b-구조-변경--선정렬축소-후-계산서브쿼리" style="position:relative;"><a href="#b-%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%84%A0%EC%A0%95%EB%A0%AC%EC%B6%95%EC%86%8C-%ED%9B%84-%EA%B3%84%EC%82%B0%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC" aria-label="b 구조 변경  선정렬축소 후 계산서브쿼리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>B. 구조 변경 — “선정렬·축소 후 계산”(서브쿼리)</h4>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">
product
  └─ <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token punctuation">(</span>인덱스 가능<span class="token punctuation">)</span>
       └─ <span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token punctuation">(</span>상위 <span class="token number">5</span>개<span class="token punctuation">)</span>
            └─ 각 행마다 <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> product_like <span class="token keyword">WHERE</span> ref_product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id<span class="token punctuation">)</span></code></pre></div>
<h2 id="읽기-전용-집계-테이블-비정규화-도입" style="position:relative;"><a href="#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%8F%84%EC%9E%85" aria-label="읽기 전용 집계 테이블 비정규화 도입 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>읽기 전용 집계 테이블 (비정규화) 도입</h2>
<p>서브쿼리 방식은 훌륭했지만, 조회할 때마다 Count 를 계산하는 작업이 마음에 걸렸다. 읽기 성능을 극한으로 끌어올리기 위해,
나는 비정규화를 도입하기로 결정했다.</p>
<p>'좋아요' 이벤트가 발생할 때 마다 집계된 like_count 를 저장하는 like_summary 테이블을 별도로 만들었다.</p>
<p>이제 조회 쿼리는 실시간 집계 없이, 미리 계산된 값을 join 으로 가져오기만 하면 된다.</p>
<p>이 새로운 모델이 기존의 '가격순 정렬'에서도 문제없이 동작하는지 먼저 확인하고, 그 다음 이 모델의 진짜 목적인 '좋아요순 정렬'의 성능을 확인해 보기로 했다</p>
<h3 id="가격순-정렬-새로운-모델의-기본-성능-확인" style="position:relative;"><a href="#%EA%B0%80%EA%B2%A9%EC%88%9C-%EC%A0%95%EB%A0%AC-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%84%B1%EB%8A%A5-%ED%99%95%EC%9D%B8" aria-label="가격순 정렬 새로운 모델의 기본 성능 확인 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>가격순 정렬: 새로운 모델의 기본 성능 확인</h3>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token comment">-- 비정규화 모델 쿼리</span>
<span class="token keyword">SELECT</span>
    p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>price<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b<span class="token punctuation">.</span>name <span class="token keyword">AS</span> brandName<span class="token punctuation">,</span>
    <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>like_count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> likeCount<span class="token punctuation">,</span>
    p<span class="token punctuation">.</span>released_at
<span class="token keyword">FROM</span> product p
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> brand b <span class="token keyword">ON</span> p<span class="token punctuation">.</span>ref_brand_id <span class="token operator">=</span> b<span class="token punctuation">.</span>id
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> like_summary s <span class="token keyword">ON</span> s<span class="token punctuation">.</span>target_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id <span class="token operator">AND</span> s<span class="token punctuation">.</span>target_type <span class="token operator">=</span> <span class="token string">'PRODUCT'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>price <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div>
<p>먼저 기존과 동일하게 price로 정렬하는 쿼리를 테스트했다. product(price) 인덱스가 있는 상태에서 실행 시간은 <code class="language-text">0.05초</code>로,
이전 서브쿼리 모델과 비슷하거나 미세하게 더 빠른 결과를 보였다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span></code></pre></div>
<p>실행 계획은 다음과 같이 filesort 없이 완벽하게 동작했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> <span class="token keyword">key</span>       <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> Extra
<span class="token comment">---|-------|--------|-----------|------|-----------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">index</span>  <span class="token operator">|</span> idx_price <span class="token operator">|</span> <span class="token number">5</span>    <span class="token operator">|</span>
<span class="token number">1</span>  <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>   <span class="token operator">|</span> <span class="token number">1</span>    <span class="token operator">|</span>
<span class="token number">1</span>  <span class="token operator">|</span> s     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> UK<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token operator">|</span> <span class="token number">1</span>    <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition
</code></pre></div>
<p>옵티마이저가 product 테이블의 idx_price를 타고, brand와 like_summary는 이미 존재하는 인덱스를 통해 효율적으로 조인하고 있었다.</p>
<p>실시간 집계의 부하가 사라진 덕분에 안정적인 성능을 보여주었다.</p>
<h3 id="좋아요순-정렬-비정규화-모델의-진짜-시험대" style="position:relative;"><a href="#%EC%A2%8B%EC%95%84%EC%9A%94%EC%88%9C-%EC%A0%95%EB%A0%AC-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%8B%9C%ED%97%98%EB%8C%80" aria-label="좋아요순 정렬 비정규화 모델의 진짜 시험대 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>좋아요순 정렬: 비정규화 모델의 진짜 시험대</h3>
<p>이제 이 모델을 도입한 진짜 이유, <strong>'좋아요순 정렬'</strong> 을 테스트할 차례다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token comment">-- 비정규화 모델 쿼리</span>
<span class="token keyword">SELECT</span>
    p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>price<span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b<span class="token punctuation">.</span>name <span class="token keyword">AS</span> brandName<span class="token punctuation">,</span>
    <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>like_count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> likeCount<span class="token punctuation">,</span>
    p<span class="token punctuation">.</span>released_at
<span class="token keyword">FROM</span> product p
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> brand b <span class="token keyword">ON</span> p<span class="token punctuation">.</span>ref_brand_id <span class="token operator">=</span> b<span class="token punctuation">.</span>id
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> like_summary s <span class="token keyword">ON</span> s<span class="token punctuation">.</span>target_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id <span class="token operator">AND</span> s<span class="token punctuation">.</span>target_type <span class="token operator">=</span> <span class="token string">'PRODUCT'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> s<span class="token punctuation">.</span>like_count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div>
<p>'좋아요순' 정렬을 테스트하자, 쿼리 시간은 <code class="language-text">1.92초</code>. 다시 원점으로 돌아온 듯했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> <span class="token keyword">key</span>                         <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra
<span class="token comment">---|-------------|-------|-------|-----------------------------|--------|---------------------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> <span class="token boolean">NULL</span>                        <span class="token operator">|</span> <span class="token number">497349</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref<span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                     <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token boolean">NULL</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> s     <span class="token operator">|</span> eq_ref<span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition
</code></pre></div>
<p>EXPLAIN 을 확인하니, 또 다시 product 테이블을 풀 스캔하면 <strong><code class="language-text">Using filesort</code></strong> 가 발생하고 있었다.</p>
<p>like_summary 테이블에는 (target_id , target_type) 인덱스가 잘 걸려 있었지만 , 정렬 기준인 like_count 컬럼에는 인덱스가 없었다.</p>
<h3 id="단일-인덱스의-순진한-기대" style="position:relative;"><a href="#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%88%9C%EC%A7%84%ED%95%9C-%EA%B8%B0%EB%8C%80" aria-label="단일 인덱스의 순진한 기대 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>단일 인덱스의 순진한 기대</h3>
<p>가장 먼저 떠오르는 해결책은 단순했다.</p>
<p>like_summary 테이블의 like_count 컬럼에 단일 인덱스를 추가하는 것이다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">Table</span>        <span class="token operator">|</span> Key_name                    <span class="token operator">|</span> Column_name <span class="token operator">|</span> Cardinality <span class="token operator">|</span> Index_type
<span class="token comment">-------------|-----------------------------|-------------|-------------|-----------</span>
like_summary <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                     <span class="token operator">|</span> id          <span class="token operator">|</span> <span class="token number">430750</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>
like_summary <span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> target_id   <span class="token operator">|</span> <span class="token number">430750</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>
like_summary <span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> target_type <span class="token operator">|</span> <span class="token number">430750</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>
like_summary <span class="token operator">|</span> idx_like_count              <span class="token operator">|</span> like_count  <span class="token operator">|</span> <span class="token number">11</span>          <span class="token operator">|</span> <span class="token keyword">BTREE</span>
</code></pre></div>
<p>이제 옵티마이저가 이 인덱스를 타고 filesort를 피할 것이라고 기대했다. 하지만 결과는 나를 비웃는 듯했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">1.86</span> sec<span class="token punctuation">)</span></code></pre></div>
<p>실행 시간은 거의 그대로였고, 실행 계획 역시 이전과 100% 동일했다. 옵티마이저는 내가 만든 idx_like_count를 완전히 무시했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> <span class="token keyword">key</span>                         <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra
<span class="token comment">---|-------------|-------|-------|-----------------------------|--------|---------------------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> <span class="token boolean">NULL</span>                        <span class="token operator">|</span> <span class="token number">497349</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref<span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                     <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token boolean">NULL</span>
<span class="token number">1</span>  <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> s     <span class="token operator">|</span> eq_ref<span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition
</code></pre></div>
<p>왜일까? 옵티마이저는 '비용(Cost)' 기반으로 생각한다.</p>
<p>이 쿼리에는 s.target_type = 'PRODUCT'라는 숨겨진 필터 조건이 있다.</p>
<p>옵티마이저 입장에서 idx_like_count만 사용하면, 'PRODUCT' 타입이 아닌 다른 타입의 데이터까지 모두 읽은 뒤에 필터링해야 하는 비효율이 발생할 수 있다.</p>
<p>결국 옵티마이저는 "그렇게 하느니 차라리 product 테이블 전체를 읽고 정렬하는 게 낫겠다"고 판단해버린 것이다.</p>
<h3 id="복합-인덱스의-배신-그리고-의문" style="position:relative;"><a href="#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EB%B0%B0%EC%8B%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%98%EB%AC%B8" aria-label="복합 인덱스의 배신 그리고 의문 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>복합 인덱스의 배신, 그리고 의문</h3>
<p>"아, 필터링 조건도 함께 넣어줘야 하는구나!"</p>
<p>나는 필터링(target_type)과 정렬(like_count)을 모두 포함하는 복합 인덱스를 생성했다.</p>
<p>이것이야말로 정답이라고 확신했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">Table</span>         <span class="token operator">|</span> Key_name                     <span class="token operator">|</span> <span class="token keyword">Column</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>            <span class="token operator">|</span> Non_unique <span class="token operator">|</span> Cardinality <span class="token operator">|</span> Index_type
<span class="token comment">--------------|------------------------------|---------------------|------------|------------|-----------</span>
like_summary  <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                      <span class="token operator">|</span> id                  <span class="token operator">|</span> <span class="token number">0</span>          <span class="token operator">|</span> <span class="token number">430750</span>     <span class="token operator">|</span> <span class="token keyword">BTREE</span>
like_summary  <span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> target_id<span class="token punctuation">,</span> target_type <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span> <span class="token number">430750</span>     <span class="token operator">|</span> <span class="token keyword">BTREE</span>
like_summary  <span class="token operator">|</span> idx_target_type_like_count   <span class="token operator">|</span> target_type<span class="token punctuation">,</span> like_count <span class="token operator">|</span> <span class="token number">1</span>       <span class="token operator">|</span> <span class="token number">11</span>         <span class="token operator">|</span> <span class="token keyword">BTREE</span>
</code></pre></div>
<p>하지만 결과는 다시 한번 나를 좌절시켰다. 실행 시간은 <code class="language-text">1.84초</code>,</p>
<p>실행 계획은 여전히 product 테이블을 풀 스캔하며 Using filesort를 수행하고 있었다</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> <span class="token keyword">key</span>                         <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> Extra
<span class="token comment">---|-------|--------|-----------------------------|------|-------------------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> p     <span class="token operator">|</span> <span class="token keyword">ALL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>                        <span class="token operator">|</span> <span class="token number">497349</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort
<span class="token number">1</span>  <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                     <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span>
<span class="token number">1</span>  <span class="token operator">|</span> s     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition
</code></pre></div>
<p>분명히 쿼리의 모든 조건을 만족하는 완벽한 인덱스를 만들었는데, 왜 옵티마이저는 계속해서 가장 비효율적인 길을 고집하는 걸까?</p>
<p>여기서 나는 문제의 본질이 인덱스 자체가 아니라, 데이터베이스가 일하는 방식에 있음을 깨달았다.</p>
<h3 id="driving-table을-바꾸면-003초가-보인다" style="position:relative;"><a href="#driving-table%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4-003%EC%B4%88%EA%B0%80-%EB%B3%B4%EC%9D%B8%EB%8B%A4" aria-label="driving table을 바꾸면 003초가 보인다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Driving Table을 바꾸면 0.03초가 보인다</h3>
<p>해답은 <code class="language-text">Driving Table</code> 과 <code class="language-text">Driven Table</code> 개념에 있었다.</p>
<p>JOIN 시 가장 먼저 읽는 기준 테이블이 <code class="language-text">Driving Table</code> 이고, 그 결과에 따라 나중에 참조되는 테이블이 <code class="language-text">Driven Table</code> 이다.
JOIN 성능은 얼마나 작은 <code class="language-text">Driving Table</code> 을 가지고 시작하는 가에 달려 있다.</p>
<p>옵티마이저는 FROM product p ... 구문을 보고, 50만 건의 product 테이블을 <code class="language-text">Driving Table</code>로 선택하고 있었다.</p>
<p>즉, 50만 번의 루프를 돌며 like_summary를 찾아 붙인 뒤, 이 거대한 결과물을 통째로 정렬하고 있었던 것이다.</p>
<p>이 방식에서는 like_summary에 만든 그 어떤 인덱스도 정렬에 사용될 수 없다.</p>
<p>우리가 원했던 이상적인 순서는 그 반대였다.</p>
<ol>
<li><code class="language-text">Driving Table</code>: like_summary에서 like_count가 높은 5개를 인덱스를 이용해 먼저 찾는다.</li>
<li><code class="language-text">Driven Table</code>: 찾아낸 5개를 가지고 product 테이블을 조인한다.</li>
</ol>
<h3 id="straight_join으로-조인-순서-고정-mysql" style="position:relative;"><a href="#straight_join%EC%9C%BC%EB%A1%9C-%EC%A1%B0%EC%9D%B8-%EC%88%9C%EC%84%9C-%EA%B3%A0%EC%A0%95-mysql" aria-label="straight_join으로 조인 순서 고정 mysql permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>STRAIGHT_JOIN으로 조인 순서 고정 (MySQL)</h3>
<p>옵티마이저가 product 테이블을 Driving Table로 선택하는 것을 막기 위해, JOIN 순서를 직접 제어할 필요가 있었다. FROM 절의 테이블 순서를 변경하고 STRAIGHT_JOIN 힌트를 사용하여, like_summary 테이블부터 조인이 시작되도록 쿼리를 수정했다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span>
    like_summary s
STRAIGHT_JOIN <span class="token comment">-- 이 힌트로 JOIN 순서를 고정!</span>
    product p <span class="token keyword">ON</span> s<span class="token punctuation">.</span>target_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span>
    brand b <span class="token keyword">ON</span> p<span class="token punctuation">.</span>ref_brand_id <span class="token operator">=</span> b<span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span>
    s<span class="token punctuation">.</span>target_type <span class="token operator">=</span> <span class="token string">'PRODUCT'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    s<span class="token punctuation">.</span>like_count <span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div>
<p>결과는 완벽했다. <code class="language-text">1.84초</code> 걸리던 쿼리가 <code class="language-text">0.03초</code>로 단축되었다. 실행 계획 또한 의도했던 대로 변경된 것을 확인할 수 있었다.</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">id <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> <span class="token keyword">key</span>                        <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> Extra
<span class="token comment">---|-------|--------|----------------------------|--------|--------------------------------</span>
<span class="token number">1</span>  <span class="token operator">|</span> s     <span class="token operator">|</span> ref    <span class="token operator">|</span> idx_target_type_like_count <span class="token operator">|</span> <span class="token number">215375</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> Backward <span class="token keyword">index</span> scan
<span class="token number">1</span>  <span class="token operator">|</span> p     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                    <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span>
<span class="token number">1</span>  <span class="token operator">|</span> b     <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>                    <span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span>

</code></pre></div>
<ul>
<li><code class="language-text">Driving Table</code> : 시작 테이블이 like_summary(s)로 변경되었다.</li>
<li><code class="language-text">Extra: Backward index scan: filesort</code> 가 사라졌다. 옵티마이저는 우리가 만든 idx_target_type_like_count 복합 인덱스를 뒤에서부터 거꾸로 읽어, 정렬 작업을 하지 않고도 DESC 정렬을 완벽하게 구현했다.</li>
</ul>
<br/>
<h4 id="c-집계-테이블--올바른-드라이빙-테이블" style="position:relative;"><a href="#c-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94--%EC%98%AC%EB%B0%94%EB%A5%B8-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99-%ED%85%8C%EC%9D%B4%EB%B8%94" aria-label="c 집계 테이블  올바른 드라이빙 테이블 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C. 집계 테이블 + 올바른 드라이빙 테이블</h4>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql">
like_summary <span class="token punctuation">(</span>idx: target_type<span class="token punctuation">,</span> like_count<span class="token punctuation">)</span>  ← 역방향 인덱스 스캔으로 상위 <span class="token number">5</span>
  └─ <span class="token keyword">JOIN</span> product <span class="token punctuation">(</span>PK<span class="token punctuation">)</span>
       └─ <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> brand <span class="token punctuation">(</span>PK<span class="token punctuation">)</span></code></pre></div>
<h2 id="성능과-비즈니스-요구사항-사이에서" style="position:relative;"><a href="#%EC%84%B1%EB%8A%A5%EA%B3%BC-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%82%AC%EC%9D%B4%EC%97%90%EC%84%9C" aria-label="성능과 비즈니스 요구사항 사이에서 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>성능과 비즈니스 요구사항 사이에서</h2>
<p>STRAIGHT_JOIN을 통해 like_summary를 Driving Table로 삼는 순간, <code class="language-text">1.84초</code> 걸리던 쿼리는 <code class="language-text">0.03초</code>로 단축되었다. <br/>하지만 이 완벽해 보이는 해결책에는, 한 가지 치명적인 비즈니스적 함정이 숨어있었다. like_summary를 기준으로 조인을 시작하면, '좋아요가 0개인 상품'은 결과에서 영원히 제외된다. LEFT JOIN을 통해 '좋아요가 없는 상품'도 목록에 포함시키려 했던 초기 요구사항과 정면으로 배치되는 결과였다.</p>
<p>결국, 우리는 근본적인 질문으로 돌아왔다. 이 API의 진짜 주인공은 누구인가?</p>
<p>이 API는 '좋아요 목록 조회'가 아닌, '상품 목록 조회' API다. 대부분의 사용자는 가격순, 최신순으로 상품을 탐색할 것이고, 이때 기준이 되는 테이블은 당연히 product 테이블이다. 즉, product 테이블이 <code class="language-text">Driving Table</code>이 되는 것이 이 API의 본질에 더 부합했다.</p>
<h3 id="driving-table-선택의-원칙-order-by가-열쇠를-쥐고-있다" style="position:relative;"><a href="#driving-table-%EC%84%A0%ED%83%9D%EC%9D%98-%EC%9B%90%EC%B9%99-order-by%EA%B0%80-%EC%97%B4%EC%87%A0%EB%A5%BC-%EC%A5%90%EA%B3%A0-%EC%9E%88%EB%8B%A4" aria-label="driving table 선택의 원칙 order by가 열쇠를 쥐고 있다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Driving Table 선택의 원칙: ORDER BY가 열쇠를 쥐고 있다</h3>
<p>JOIN 튜닝의 핵심은 "어떻게 하면 Driving Table의 작업 범위를 가장 작게 줄일 수 있는가?"이다. 그리고 그 열쇠는 바로 <code class="language-text">ORDER BY</code>와 <code class="language-text">LIMIT</code> 절이 쥐고 있다.</p>
<p>옵티마이저가 <code class="language-text">filesort</code>를 피하는 유일한 방법은, 이미 정렬된 순서대로 데이터를 읽는 것, 즉 인덱스를 활용하는 것이다.</p>
<ul>
<li><strong>ORDER BY p.price</strong> : <code class="language-text">product</code> 테이블의 price 인덱스를 순서대로 LIMIT 5 만큼만 읽으면 정렬이 끝난다.</li>
<li><strong>ORDER BY s.like_count</strong> : <code class="language-text">like_summary</code> 테이블의 like_count 인덱스를 순서대로 LIMIT 5 만큼만 읽으면 정렬이 끝난다.</li>
</ul>
<p>즉, ORDER BY의 대상 컬럼이 속한 테이블이 Driving Table이 되어야만 filesort를 피하고 최고의 성능을 낼 수 있다.</p>
<p>이 원칙은 우리에게 명확한 딜레마를 안겨주었다.</p>
<ul>
<li>'가격순/최신순' 정렬을 위해서는 product가 Driving Table이 되어야 한다.</li>
<li>'좋아요순' 정렬을 위해서는 like_summary가 Driving Table이 되어야 한다.</li>
</ul>
<p>하나의 쿼리로는 이 두 마리 토끼를 동시에 잡을 수 없었다.</p>
<h3 id="포기가-아닌-분리separation" style="position:relative;"><a href="#%ED%8F%AC%EA%B8%B0%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%B6%84%EB%A6%ACseparation" aria-label="포기가 아닌 분리separation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>포기가 아닌, 분리(Separation)</h3>
<p>그렇다면 우리는 '좋아요순' 정렬의 성능을 포기해야만 할까?</p>
<p>이 지점에서 우리는 데이터베이스의 한계를 애플리케이션의 유연성으로 극복하기로 했다. 모든 정렬 조건을 단 하나의 쿼리로 해결하겠다는 생각을 버리는 것이다.</p>
<p>우리의 Service Layer는 지휘자의 역할을 맡는다. Controller로부터 들어온 정렬 조건을 보고, 그에 맞는 가장 최적화된 '전용 쿼리'를 호출해주는 것이다.</p>
<p>"productSort = PRICE_ASC 또는 LATEST_DESC 요청이 들어오면?"</p>
<p>product를 Driving Table로 삼아 <code class="language-text">filesort</code> 없이 price 또는 released_at 인덱스를 타는 일반 쿼리를 호출한다. <br/>(성능: <code class="language-text">0.05초</code>)</p>
<p>"productSort = LIKE_COUNT_DESC 요청이 들어오면?"</p>
<p>like_summary를 Driving Table로 삼아 <code class="language-text">filesort</code> 없이 like_count 인덱스를 타는 '좋아요순 전용' 쿼리 (STRAIGHT_JOIN 사용)를 호출한다. <br/> (성능: <code class="language-text">0.03초</code>)</p>
<p>이 방식은 '좋아요순' 정렬 시 '좋아요 0개' 상품이 제외된다는 비즈니스적 타협을 동반하지만, "인기 있는 상품을 본다"는 사용자의 의도에 더 부합하는 합리적인 선택이었다.</p>
<h2 id="튜닝-여정-한눈에-보기" style="position:relative;"><a href="#%ED%8A%9C%EB%8B%9D-%EC%97%AC%EC%A0%95-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EA%B8%B0" aria-label="튜닝 여정 한눈에 보기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>튜닝 여정 한눈에 보기</h2>
<p>이번 5.38초에서 0.03초에 이르는 기나긴 튜닝 여정을 한눈에 요약하면 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th align="left">단계</th>
<th align="left">쿼리/전략</th>
<th align="left">주요 증상/계획</th>
<th align="left">시간</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1</td>
<td align="left"><code class="language-text">JOIN</code> + <code class="language-text">GROUP BY</code> + <code class="language-text">ORDER BY</code></td>
<td align="left"><code class="language-text">Using temporary; Using filesort</code>, <code class="language-text">p: type=ALL</code></td>
<td align="left"><strong>5.38s</strong></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code class="language-text">price</code> 인덱스만 추가</td>
<td align="left">여전히 <code class="language-text">GROUP BY</code>가 막음</td>
<td align="left"><strong>5.35s</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">구조변경 (서브쿼리로 <code class="language-text">likeCount</code>)</td>
<td align="left">임시테이블 제거, <code class="language-text">filesort</code>만 남음</td>
<td align="left"><strong>0.63s</strong></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">+ <code class="language-text">price</code> 인덱스 활용</td>
<td align="left">인덱스 순서로 상위 N만 읽기</td>
<td align="left"><strong>0.06s</strong></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">집계테이블 도입 (<code class="language-text">ORDER BY price</code>)</td>
<td align="left"><code class="language-text">filesort</code> 없음, 안정적인 성능 확인</td>
<td align="left"><strong>0.05s</strong></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">집계테이블 도입 (<code class="language-text">ORDER BY like_count</code>)</td>
<td align="left"><code class="language-text">Using filesort</code>, <code class="language-text">p</code>가 드라이빙 테이블</td>
<td align="left"><strong>1.92s</strong></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code class="language-text">like_count</code> 단일 인덱스</td>
<td align="left">옵티마이저가 무시 (비용상 불리)</td>
<td align="left"><strong>1.86s</strong></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code class="language-text">(target_type, like_count)</code> 복합 인덱스</td>
<td align="left">여전히 <code class="language-text">p</code>가 드라이빙</td>
<td align="left"><strong>1.84s</strong></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code class="language-text">STRAIGHT_JOIN</code>로 <code class="language-text">s</code> → <code class="language-text">p</code></td>
<td align="left">인덱스 역스캔, 상위 N 선별 후 <code class="language-text">JOIN</code></td>
<td align="left"><strong>0.03s</strong></td>
</tr>
</tbody>
</table>
<h2 id="맺으며" style="position:relative;"><a href="#%EB%A7%BA%EC%9C%BC%EB%A9%B0" aria-label="맺으며 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>맺으며</h2>
<h3 id="인덱스는-감이-아닌-데이터로-설계한다" style="position:relative;"><a href="#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%8A%94-%EA%B0%90%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%9C%EB%8B%A4" aria-label="인덱스는 감이 아닌 데이터로 설계한다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>인덱스는 감이 아닌 데이터로 설계한다.</h3>
<p>이번 성능 튜닝을 통해 배운 교훈을 다시 정리하면 다음과 같다.</p>
<ol>
<li>
<p><strong>단일 쿼리의 편리함이 항상 성능을 보장하지는 않았다.</strong> <br/> :JOIN과 GROUP BY의 간결함 이면에는 <code class="language-text">Using temporary;</code> <code class="language-text">Using filesort</code>라는 거대한 비용이 숨어있을 수 있었고, 실행 계획은 그 실제 비용을 보여주는 가장 정직한 지표였다.</p>
</li>
<li>
<p><strong>인덱스는 생성보다 '활용'이 더 중요했다.</strong> <br/> :쿼리 구조 자체가 인덱스를 활용할 수 없도록 설계되었거나, 옵티마이저가 비효율적인 테이블부터 읽기 시작한다면 인덱스는 무용지물이었다.</p>
</li>
<li>
<p><strong>옵티마이저의 판단이 항상 최선은 아니었다.</strong> <br/> :비용 기반으로 동작하는 옵티마이저가 데이터의 분포나 쿼리의 복잡성 때문에 때로는 최적의 실행 계획을 찾지 못했다. 이런 상황에서는 STRAIGHT_JOIN 같은 힌트를 통해 개발자가 직접 실행 계획에 개입하는 것이 효과적인 해결책이 될 수 있었다.</p>
</li>
<li>
<p><strong>모든 결정은 추측이 아닌 데이터에 기반해야 한다.</strong> <br/> :EXPLAIN과 k6가 보여주는 객관적인 데이터만이 '감'에 의존한 예상을 바로잡고, 가장 신뢰할 수 있는 개선의 방향을 알려주었다.</p>
</li>
</ol>
<p>결국 "인덱스를 걸었다"는 사실에 안주하는 것이 아니라, 데이터베이스가 어떻게 동작하는지 이해하고, 실행 계획이라는 데이터를 근거로 꾸준히 의심하고 검증하는 과정이야말로 서비스의 안정성을 지키는 가장 중요한 습관임을 다시 한번 느꼈다.</p></div><style data-emotion="css fmunkh">.css-fmunkh{position:absolute;top:0;left:768px;height:100%;padding-left:4rem;}@media (max-width: 1400px){.css-fmunkh{display:none;}}</style><aside class="css-fmunkh ek4ynda1"><style data-emotion="css 1s5ilwz">.css-1s5ilwz{position:-webkit-sticky;position:sticky;top:6rem;width:240px;overflow:hidden;font-size:0.8rem;}.css-1s5ilwz p{margin:0;}.css-1s5ilwz a{display:block;padding:0.5rem;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;border-radius:4px;-webkit-transition:all 0.1s ease-out;transition:all 0.1s ease-out;}.css-1s5ilwz a:hover{background-color:#badcff;}.css-1s5ilwz ul:first-child{border-left:none;}.css-1s5ilwz ul{margin-left:0.5rem;padding:0 0.5rem;list-style:none;border-left:2px solid #e2e5e6;}</style><nav class="css-1s5ilwz ek4ynda0"><ul>
<li>
<p><a href="#group-by%EA%B0%80-order-by-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EB%A7%89%EB%8A%94-%EC%88%9C%EA%B0%84">GROUP BY가 ORDER BY 인덱스를 막는 순간</a></p>
</li>
<li>
<p><a href="#%EC%99%9C-price-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%EC%95%88-%ED%83%80%EC%A7%80-group-by%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84">왜 price 인덱스가 안 타지? (GROUP BY의 우선순위)</a></p>
<ul>
<li>
<ul>
<li><a href="#a-%EC%B4%88%EA%B8%B0%EB%8A%90%EB%A6%B0-%EA%B2%BD%EB%A1%9C--join--group-by--order-by">A. 초기(느린) 경로 — JOIN + GROUP BY + ORDER BY</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EB%A8%BC%EC%A0%80-%EC%A4%84%EC%9D%B4%EA%B3%A0-%EB%82%98%EC%A4%91%EC%97%90-%EA%B3%84%EC%82%B0%ED%95%9C%EB%8B%A4-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC--limit-%EC%A0%84%EB%9E%B5">먼저 줄이고 나중에 계산한다: 서브쿼리 + LIMIT 전략</a></p>
<ul>
<li>
<p><a href="#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD%EB%A7%8C-%EC%A0%81%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EC%A0%88%EB%B0%98%EC%9D%98-%EC%84%B1%EA%B3%B5">구조 변경만 적용했을 때: 절반의 성공</a></p>
</li>
<li>
<p><a href="#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%8B%9C%EB%84%88%EC%A7%80%EC%9D%98-%EB%B0%9C%ED%98%84">구조 변경 + 인덱스: 진정한 시너지의 발현</a></p>
<ul>
<li><a href="#b-%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%84%A0%EC%A0%95%EB%A0%AC%EC%B6%95%EC%86%8C-%ED%9B%84-%EA%B3%84%EC%82%B0%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC">B. 구조 변경 — “선정렬·축소 후 계산”(서브쿼리)</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%8F%84%EC%9E%85">읽기 전용 집계 테이블 (비정규화) 도입</a></p>
<ul>
<li>
<p><a href="#%EA%B0%80%EA%B2%A9%EC%88%9C-%EC%A0%95%EB%A0%AC-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%84%B1%EB%8A%A5-%ED%99%95%EC%9D%B8">가격순 정렬: 새로운 모델의 기본 성능 확인</a></p>
</li>
<li>
<p><a href="#%EC%A2%8B%EC%95%84%EC%9A%94%EC%88%9C-%EC%A0%95%EB%A0%AC-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%8B%9C%ED%97%98%EB%8C%80">좋아요순 정렬: 비정규화 모델의 진짜 시험대</a></p>
</li>
<li>
<p><a href="#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%88%9C%EC%A7%84%ED%95%9C-%EA%B8%B0%EB%8C%80">단일 인덱스의 순진한 기대</a></p>
</li>
<li>
<p><a href="#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EB%B0%B0%EC%8B%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%98%EB%AC%B8">복합 인덱스의 배신, 그리고 의문</a></p>
</li>
<li>
<p><a href="#driving-table%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4-003%EC%B4%88%EA%B0%80-%EB%B3%B4%EC%9D%B8%EB%8B%A4">Driving Table을 바꾸면 0.03초가 보인다</a></p>
</li>
<li>
<p><a href="#straight_join%EC%9C%BC%EB%A1%9C-%EC%A1%B0%EC%9D%B8-%EC%88%9C%EC%84%9C-%EA%B3%A0%EC%A0%95-mysql">STRAIGHT_JOIN으로 조인 순서 고정 (MySQL)</a></p>
<ul>
<li><a href="#c-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94--%EC%98%AC%EB%B0%94%EB%A5%B8-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99-%ED%85%8C%EC%9D%B4%EB%B8%94">C. 집계 테이블 + 올바른 드라이빙 테이블</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%84%B1%EB%8A%A5%EA%B3%BC-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%82%AC%EC%9D%B4%EC%97%90%EC%84%9C">성능과 비즈니스 요구사항 사이에서</a></p>
<ul>
<li><a href="#driving-table-%EC%84%A0%ED%83%9D%EC%9D%98-%EC%9B%90%EC%B9%99-order-by%EA%B0%80-%EC%97%B4%EC%87%A0%EB%A5%BC-%EC%A5%90%EA%B3%A0-%EC%9E%88%EB%8B%A4">Driving Table 선택의 원칙: ORDER BY가 열쇠를 쥐고 있다</a></li>
<li><a href="#%ED%8F%AC%EA%B8%B0%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%B6%84%EB%A6%ACseparation">포기가 아닌, 분리(Separation)</a></li>
</ul>
</li>
<li>
<p><a href="#%ED%8A%9C%EB%8B%9D-%EC%97%AC%EC%A0%95-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EA%B8%B0">튜닝 여정 한눈에 보기</a></p>
</li>
<li>
<p><a href="#%EB%A7%BA%EC%9C%BC%EB%A9%B0">맺으며</a></p>
<ul>
<li><a href="#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%8A%94-%EA%B0%90%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%9C%EB%8B%A4">인덱스는 감이 아닌 데이터로 설계한다.</a></li>
</ul>
</li>
</ul></nav></aside></div><style data-emotion="css b3pts2">.css-b3pts2{display:grid;place-items:center;margin-top:40px;padding:25px 0;font-size:15px;color:#aaa;font-weight:bold;text-align:center;line-height:1.2;background-color:#f0f0f0;}@media (max-width: 768px){.css-b3pts2{font-size:13px;}}</style><div class="css-b3pts2 ehmnl591">© <!-- -->2025<!-- --> 박건희<style data-emotion="css 1tmvi1x">.css-1tmvi1x{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:5px;font-size:25px;}.css-1tmvi1x>a{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:inherit;}@media (max-width: 768px){.css-1tmvi1x{font-size:20px;}}</style><div class="css-1tmvi1x ehmnl590"><a href="https://github.com/connieya" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></a></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/why-is-my-query-slow-after-indexing/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-d86d62b906f35bb1157d.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-8535dbf06a13c1090bd2.js\"],\"component---src-pages-blog-tsx\":[\"/component---src-pages-blog-tsx-110f92f4ff04fceed11c.js\"],\"component---src-pages-guestbook-tsx\":[\"/component---src-pages-guestbook-tsx-3b2f484bb86cf819b583.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-fd11d8a720f37f9fad74.js\"],\"component---src-templates-post-template-tsx\":[\"/component---src-templates-post-template-tsx-9318c1189ed8b7386476.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="f1008bb14836f2f8240b";</script><script src="/webpack-runtime-e45a8ed4c8ddbf8ac707.js" async></script><script src="/framework-a02ced70e77b2a7c030d.js" async></script><script src="/app-d86d62b906f35bb1157d.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>