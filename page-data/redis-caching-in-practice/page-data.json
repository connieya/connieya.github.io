{"componentChunkName":"component---src-templates-post-template-tsx","path":"/redis-caching-in-practice/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"tableOfContents":"<ul>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%95%9C%EA%B3%84\">인덱스의 한계</a></li>\n<li><a href=\"#redis%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0\">Redis를 선택한 이유</a></li>\n<li><a href=\"#%EC%83%81%ED%92%88-%EC%83%81%EC%84%B8-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%B1\">상품 상세 페이지 캐싱</a></li>\n<li><a href=\"#hash-vs-string\">Hash vs String</a></li>\n<li><a href=\"#%EA%B8%80-%EC%9E%91%EC%84%B1%EC%A4%91\">글 작성중............</a></li>\n</ul>","html":"<p>개발자로서 우리는 항상 더 빠른 응답 속도와 더 나은 사용자 경험을 고민합니다. 특히 조회가 많은 이커머스 시스템에서 성능 개선은 숙명과도 같죠. 가장 먼저 떠오르는 해결책은 단연 '인덱스(Index)'입니다. 하지만 인덱스만으로 모든 것이 해결될까요?</p>\n<h2 id=\"인덱스의-한계\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"인덱스의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 한계</h2>\n<p>물론 인덱스는 훌륭한 친구입니다. 특정 조건의 데이터를 찾아내는 속도를 드라마틱하게 향상시켜 주니까요. 실제로 저 또한 인덱스만으로 조회 쿼리의 실행 계획을 개선하고 응답 속도를 N배 향상시킨 경험이 있습니다.</p>\n<p><strong><a href=\"https://connieya.github.io/why-is-my-query-slow-after-indexing/\" target=\"_blank\" rel=\"nofollow\">인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기)</a></strong></p>\n<p>하지만 사용자가 여러 필터(카테고리, 가격대, 브랜드, 색상...)를 조합하기 시작하면 이야기는 달라집니다. 모든 필터 조합에 맞춰 인덱스를 거는 건 사실상 불가능하고, 인덱스가 많아질수록 오히려 쓰기(Write) 성능에 악영향을 줍니다.\n문득 이런 생각이 들었습니다.</p>\n<p>자주 조회되는 데이터라는 것은 그만큼 요청이 많다는 의미입니다. 그런데 이 데이터가 자주 변경되지 않는다면, 매번 요청이 올 때마다 데이터베이스까지 가서 I/O 작업을 수행하는 것은 명백한 비효율이었습니다.</p>\n<p>이 불필요한 I/O를 없애려면, 데이터를 꼭 데이터베이스에만 둘 필요는 없다는 결론에 다다랐습니다. I/O 작업 자체가 없는 메모리처럼 훨씬 빠른 곳에 데이터를 저장해두고 꺼내 쓴다면 어떨까요?</p>\n<h2 id=\"redis를-선택한-이유\" style=\"position:relative;\"><a href=\"#redis%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"redis를 선택한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis를 선택한 이유</h2>\n<p>캐싱을 위한 도구는 많지만, 저의 선택은 레디스였습니다. 이유는 명확했습니다.</p>\n<ul>\n<li>In-Memory 기반의 압도적인 속도: 모든 데이터를 디스크가 아닌 메모리에 저장하기에, DB와는 비교할 수 없는 응답 속도를 자랑합니다.</li>\n<li>다채로운 자료구조: 단순한 Key-Value를 넘어 해시(Hashes), 정렬된 집합(Sorted Sets) 등 상황에 맞는 최적의 '그릇'을 제공합니다. 이는 데이터를 더 효율적으로 저장하고 관리할 수 있게 해줍니다.</li>\n</ul>\n<p>자, 이제 레디스라는 강력한 무기를 들었으니, 어떤 적부터 공략할지 정해야겠죠?</p>\n<h2 id=\"상품-상세-페이지-캐싱\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%92%88-%EC%83%81%EC%84%B8-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%B1\" aria-label=\"상품 상세 페이지 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상품 상세 페이지 캐싱</h2>\n<p>이커머스에서 사용자들이 가장 많이, 그리고 반복적으로 보는 페이지는 단연 '상품 상세 페이지'입니다. 여기에는 상품명, 가격, 브랜드, 설명, 그리고 '좋아요' 수 같은 데이터가 있죠.</p>\n<ul>\n<li>상품명, 브랜드, 설명: 거의 바뀌지 않습니다.</li>\n<li>가격: 가끔 프로모션으로 변경됩니다.</li>\n<li>좋아요 수: 사용자의 행동에 따라 꽤 빈번하게 바뀝니다.</li>\n</ul>\n<p>이렇게 데이터의 변경 빈도가 제각각이지만, 전반적으로는 '읽기' 작업이 '쓰기' 작업보다 압도적으로 많은, 캐싱을 적용하기에 완벽한 대상이었습니다.</p>\n<h2 id=\"hash-vs-string\" style=\"position:relative;\"><a href=\"#hash-vs-string\" aria-label=\"hash vs string permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash vs String</h2>\n<p>상품 상세 정보는 여러 필드로 구성된 객체 형태이니, 레디스에 저장할 방법은 크게 두 가지였습니다.</p>\n<ul>\n<li>JSON String: 객체를 통째로 JSON 문자열로 직렬화해서 저장.</li>\n<li>Hash: 상품 ID를 Key로, 나머지 필드들을 Hash의 Field-Value 쌍으로 저장.</li>\n</ul>\n<p>만약 가격이나 '좋아요' 수만 살짝 바뀌었는데, 거대한 JSON 문자열 전체를 다시 읽고, 수정하고, 덮어써야 한다면 너무 비효율적이지 않을까요?</p>\n<p>반면 해시(Hash) 자료구조는 HINCRBY 같은 명령어로 '좋아요' 수만 원자적으로(atomic) 1 증가시키는 등 필드 단위의 부분 업데이트가 가능합니다. 이 유연함 때문에 저는 망설임 없이 해시를 선택했습니다.</p>\n<h2 id=\"글-작성중\" style=\"position:relative;\"><a href=\"#%EA%B8%80-%EC%9E%91%EC%84%B1%EC%A4%91\" aria-label=\"글 작성중 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글 작성중............</h2>","timeToRead":1,"frontmatter":{"title":"DB 가 힘들어 해요 : 인덱스를 넘어 레디스 캐싱으로 조회 성능 올리기","summary":null,"date":"2025-09-12","categories":["cache"],"thumbnail":null}}}]}},"pageContext":{"slug":"/redis-caching-in-practice/"}},"staticQueryHashes":[],"slicesMap":{}}