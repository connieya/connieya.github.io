{"componentChunkName":"component---src-templates-post-template-tsx","path":"/redis-caching-in-practice/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%95%9C%EA%B3%84\">인덱스의 한계</a></p>\n</li>\n<li>\n<p><a href=\"#redis%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0\">Redis를 선택한 이유</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%83%81%ED%92%88-%EC%83%81%EC%84%B8-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%B1\">상품 상세 페이지 캐싱</a></p>\n</li>\n<li>\n<p><a href=\"#hash-vs-string\">Hash vs String</a></p>\n</li>\n<li>\n<p><a href=\"#cache-aside-%ED%8C%A8%ED%84%B4-%EC%BA%90%EC%8B%9C-%EB%AF%B8%EC%8A%A4-%EC%B2%98%EB%A6%AC\">Cache-Aside 패턴: 캐시 미스 처리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%96%B8%EC%A0%9C-%EB%B9%84%EC%9A%B8-%EA%B2%83%EC%9D%B8%EA%B0%80\">캐시를 언제 비울 것인가?</a></p>\n<ul>\n<li><a href=\"#%EC%A2%8B%EC%95%84%EC%9A%94-cache-first\">좋아요: Cache-First</a></li>\n<li><a href=\"#%EA%B0%80%EA%B2%A9-db-first-%ED%82%A4-%EC%82%AD%EC%A0%9C--ttl\">가격: DB-First, 키 삭제 + TTL</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#ttl%EC%9D%B4-%EB%81%9D%EB%82%98%EB%8A%94-%EA%B7%B8-%EC%88%9C%EA%B0%84\">TTL이 끝나는 그 순간</a></p>\n<ul>\n<li><a href=\"#ttl%EC%9D%84-%EC%A1%B0%EA%B8%88-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EC%A3%BC%EC%9E%90\">TTL을 조금 다르게 주자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%8A%B9%EC%A0%95-%ED%82%A4%EB%A1%9C-%EB%AA%B0%EB%A6%AC%EB%8A%94-%ED%8A%B8%EB%9E%98%ED%94%BD\">특정 키로 몰리는 트래픽</a></p>\n<ul>\n<li><a href=\"#%ED%95%9C-%EB%B2%88%EB%A7%8C-db%EC%97%90-%EB%8B%A4%EB%85%80%EC%98%A4%EA%B8%B0\">한 번만 DB에 다녀오기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%A7%80%EB%A7%89-%EA%B3%A0%EB%AF%BC-%EC%A1%B4%EC%9E%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0\">마지막 고민: 존재하지 않는 데이터</a></p>\n<ul>\n<li><a href=\"#%EC%BA%90%EC%8B%9C-%EA%B4%80%ED%86%B5-%EB%8C%80%EC%9D%91-%EC%97%86%EC%9D%8C%EB%8F%84-%EC%BA%90%EC%8B%B1%ED%95%98%EA%B8%B0\">캐시 관통 대응: \"없음\"도 캐싱하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\">맺으며</a></p>\n</li>\n</ul>","html":"<p>개발자로서 우리는 항상 더 빠른 응답 속도와 더 나은 사용자 경험을 고민합니다. 특히 조회가 많은 이커머스 시스템에서 성능 개선은 필수 과제 중 하나입니다. 가장 먼저 떠오르는 해결책은 단연 <strong><code class=\"language-text\">인덱스(Index)</code></strong> 입니다. 하지만 인덱스만으로 모든 것이 해결될까요?</p>\n<h2 id=\"인덱스의-한계\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"인덱스의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 한계</h2>\n<p>물론 인덱스는 가장 기본적이면서도 강력한 해결책입니다.</p>\n<p>특정 조건의 데이터를 찾아내는 속도를 드라마틱하게 향상시켜 주니까요. 실제로 저 또한 인덱스만으로 조회 쿼리의 실행 계획을 개선하고 응답 속도를 N배 향상시킨 경험이 있습니다.</p>\n<p><strong><a href=\"https://connieya.github.io/why-is-my-query-slow-after-indexing/\" target=\"_blank\" rel=\"nofollow\">인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기)</a></strong></p>\n<p>하지만 사용자가 여러 필터(카테고리, 가격대, 브랜드, 색상...)를 조합하기 시작하면 이야기는 달라집니다. 모든 필터 조합에 맞춰 인덱스를 거는 건 사실상 불가능하고, INSERT, UPDATE 시 인덱스 구조를 재정렬해야 하므로 쓰기(Write) 성능에 악영향을 줍니다.</p>\n<p>자주 조회되는 데이터라는 것은 그만큼 요청이 많다는 의미입니다. 그런데 <strong>이 데이터가 자주 변경되지 않는다면, 매번 요청이 올 때마다 데이터베이스까지 가서 I/O 작업을 수행하는 것은 비효율적 입니다.</strong></p>\n<p>이 불필요한 I/O를 없애려면, 데이터를 꼭 데이터베이스에만 둘 필요는 없다는 결론에 다다랐습니다. I/O 작업 자체가 없는 메모리처럼 훨씬 빠른 곳에 데이터를 저장해두고 꺼내 쓴다면 어떨까요?</p>\n<h2 id=\"redis를-선택한-이유\" style=\"position:relative;\"><a href=\"#redis%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"redis를 선택한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis를 선택한 이유</h2>\n<p>캐싱을 위한 도구는 많지만, 저의 선택은 레디스였습니다. 이유는 명확했습니다.</p>\n<ul>\n<li><strong>In-Memory 기반의 압도적인 속도</strong> : 모든 데이터를 디스크가 아닌 메모리에 저장하기에, DB와는 비교할 수 없는 응답 속도를 자랑합니다.</li>\n<li><strong>다채로운 자료구조</strong> : 단순한 Key-Value를 넘어 해시(Hashes), 정렬된 집합(Sorted Sets) 등 상황에 맞는 최적의 '그릇'을 제공합니다. 이는 데이터를 더 효율적으로 저장하고 관리할 수 있게 해줍니다.</li>\n</ul>\n<p>레디스를 캐시 도구로 사용하기로 했으니 아재 어떤 데이터에 캐싱을 적용할지 구체적인 대상을 선정해보겠습니다.</p>\n<h2 id=\"상품-상세-페이지-캐싱\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%92%88-%EC%83%81%EC%84%B8-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%B1\" aria-label=\"상품 상세 페이지 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상품 상세 페이지 캐싱</h2>\n<p>이커머스에서 사용자들이 반복적으로 많이 조회하는 대표적인 페이지 중 하나가 상품 상세 페이지입니다.</p>\n<p>여기에는 상품명, 가격, 브랜드, 설명, 그리고 '좋아요' 수 같은 데이터가 있습니다.</p>\n<ul>\n<li>상품명, 브랜드, 설명: 거의 바뀌지 않습니다.</li>\n<li>가격: 가끔 프로모션으로 변경됩니다.</li>\n<li>좋아요 수: 사용자의 행동에 따라 꽤 빈번하게 바뀝니다.</li>\n</ul>\n<p>전반적으로 <strong>읽기 요청이 쓰기 요청보다 압도적으로 많은 구조</strong>였고, 캐싱을 적용하기에 완벽한 대상이었습니다.</p>\n<h2 id=\"hash-vs-string\" style=\"position:relative;\"><a href=\"#hash-vs-string\" aria-label=\"hash vs string permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash vs String</h2>\n<p>상품 상세 정보는 여러 필드로 구성된 객체입니다.<br>\n저는 두 가지 방법을 고민했습니다.</p>\n<ul>\n<li><strong>JSON String</strong>: 객체 전체를 직렬화해서 문자열로 저장</li>\n<li><strong>Hash</strong>: 상품 ID를 Key로, 나머지 필드를 Field-Value 쌍으로 저장</li>\n</ul>\n<p>문제는 <strong>데이터가 바뀔 때</strong>였습니다. JSON String으로 저장하면, 가격이나 좋아요 수처럼 작은 필드가 변경되어도 전체 JSON을 다시 읽고 덮어써야 합니다.</p>\n<p>반면 해시(Hash) 자료구조는 <code class=\"language-text\">HINCRBY</code> 같은 명령어로 <strong>'좋아요' 수만 원자적으로(atomic) 1 증가시키는 등 필드 단위의 부분 업데이트</strong> 가 가능합니다. 이 유연함 때문에 저는 망설임 없이 해시를 선택했습니다.</p>\n<p>예를 들어, 좋아요 수는 Redis Hash의 <code class=\"language-text\">HINCRBY</code>를 활용해 부분 업데이트 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateLikeCount</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> productId <span class=\"token punctuation\">,</span> <span class=\"token class-name\">LikeUpdateType</span> updateType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    objectRedisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span>\n        <span class=\"token class-name\">RedisKeyManager</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PRODUCT_DETAIL_KEY</span> <span class=\"token operator\">+</span> productId<span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"likeCount\"</span><span class=\"token punctuation\">,</span>\n        updateType <span class=\"token operator\">==</span> <span class=\"token class-name\">LikeUpdateType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INCREMENT</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 하면 JSON 전체를 직렬화/역직렬화할 필요 없이, 특정 필드만 빠르게 수정할 수 있습니다.</p>\n<h2 id=\"cache-aside-패턴-캐시-미스-처리\" style=\"position:relative;\"><a href=\"#cache-aside-%ED%8C%A8%ED%84%B4-%EC%BA%90%EC%8B%9C-%EB%AF%B8%EC%8A%A4-%EC%B2%98%EB%A6%AC\" aria-label=\"cache aside 패턴 캐시 미스 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache-Aside 패턴: 캐시 미스 처리</h2>\n<p>저는 서비스 로직에서 RedisTemplate을 직접 쓰지 않고, <code class=\"language-text\">ProductCacheRepository</code>라는 추상화를 둬서 사용했습니다.<br>\n조회 로직은 대표적인 <strong>Cache-Aside 패턴</strong>을 따릅니다.</p>\n<ul>\n<li>캐시에 데이터가 있으면 그대로 반환</li>\n<li>캐시에 없으면 DB에서 조회 후 캐시에 저장</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ProductDetailInfo</span> <span class=\"token function\">getProductDetail</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> productId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ProductDetailInfo</span><span class=\"token punctuation\">></span></span> cached <span class=\"token operator\">=</span> productCacheRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findProductDetailById</span><span class=\"token punctuation\">(</span>productId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cached<span class=\"token punctuation\">.</span><span class=\"token function\">isPresent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> cached<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token class-name\">ProductDetailInfo</span> productDetailInfo <span class=\"token operator\">=</span> productRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findProductDetail</span><span class=\"token punctuation\">(</span>productId<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ProductException<span class=\"token punctuation\">.</span>ProductNotFoundException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ErrorType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PRODUCT_NOT_FOUND</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    productCacheRepository<span class=\"token punctuation\">.</span><span class=\"token function\">saveProductDetail</span><span class=\"token punctuation\">(</span>productDetailInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> productDetailInfo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>덕분에 서비스 레이어는 단순히 “캐시에 있으면 쓰고, 없으면 DB에서 가져온다”라는 직관적인 흐름을 유지할 수 있습니다.\n캐싱 로직은 모두 Repository 구현체에 숨겨져 있습니다.</p>\n<h2 id=\"캐시를-언제-비울-것인가\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%96%B8%EC%A0%9C-%EB%B9%84%EC%9A%B8-%EA%B2%83%EC%9D%B8%EA%B0%80\" aria-label=\"캐시를 언제 비울 것인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 언제 비울 것인가?</h2>\n<p>캐싱에서 가장 어려운 문제 중 하나는 <strong>언제 데이터를 무효화할 것인가</strong> 입니다.</p>\n<p>저는 처음에 TTL을 두지 않기로 했습니다. 상품 상세 정보는 자주 바뀌지 않고, 좋아요 수 같은 데이터는 Redis Hash에서 바로 갱신할 수 있기 때문입니다. 즉, 데이터가 변경될 때마다 캐시를 직접 갱신해주면 TTL은 필요 없다고 본 것이죠.</p>\n<p>하지만 운영을 해보니, 데이터의 성격에 따라 무효화 전략을 달리해야 했습니다.</p>\n<h3 id=\"좋아요-cache-first\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%95%84%EC%9A%94-cache-first\" aria-label=\"좋아요 cache first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋아요: Cache-First</h3>\n<p>좋아요 수는 실시간 반영이 중요하지만, 정합성이 완벽할 필요는 없습니다.</p>\n<p>그래서 사용자가 좋아요를 누르면 Redis Hash에 바로 반영하고(<code class=\"language-text\">HINCRBY</code>), Kafka 이벤트를 발행해 Consumer가 배치로 DB 집계를 처리하는 방식을 택했습니다.<br>\n→ 캐시 무효화는 필요하지 않았습니다. 캐시 자체가 항상 최신을 유지하고 있었으니까요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">```java\n<span class=\"token annotation punctuation\">@TransactionalEventListener</span><span class=\"token punctuation\">(</span>phase <span class=\"token operator\">=</span> <span class=\"token class-name\">TransactionPhase</span><span class=\"token punctuation\">.</span><span class=\"token constant\">AFTER_COMMIT</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Async</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProductLikeEvent<span class=\"token punctuation\">.</span>Add</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 1. 캐시에 즉시 반영</span>\n    productCacheRepository<span class=\"token punctuation\">.</span><span class=\"token function\">updateLikeCount</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">productId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">LikeUpdateType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INCREMENT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 2. Kafka 이벤트 발행 → 배치 집계 후 DB 저장</span>\n    likeEventPublisher<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProductLikeEvent<span class=\"token punctuation\">.</span>Update</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">productId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">INCREMENT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>좋아요 취소 이벤트도 같은 방식으로 동작합니다.</p>\n<h3 id=\"가격-db-first-키-삭제--ttl\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EA%B2%A9-db-first-%ED%82%A4-%EC%82%AD%EC%A0%9C--ttl\" aria-label=\"가격 db first 키 삭제  ttl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가격: DB-First, 키 삭제 + TTL</h3>\n<p>가격은 정합성이 가장 중요한 데이터입니다. 사실 DB 커밋 이후 캐시 해시(Hash)에서 가격 필드만 갱신해도 동작에는 문제가 없습니다. 하지만 가격은 단 1원의 차이도 허용되지 않는 민감한 값이기 때문에, 혹시라도 캐시에 잘못 반영된다면 큰 문제가 될 수 있습니다.</p>\n<p>그래서 저는 부분 갱신 방식 대신 아예 상품 상세 캐시 키 전체를 삭제(DEL) 하기로 했습니다. 이후 요청이 들어오면 자연스럽게 캐시 미스(Cache Miss)가 발생하고, DB에서 최신 가격을 읽어 캐시에 다시 적재하는 방식입니다.\n가격 변경은 빈번하지 않으므로, 이렇게 다소 과감하게 캐시를 통째로 지워도 충분히 합리적이라고 판단했습니다.</p>\n<p>또한 캐시 재적재 시에는 키 단위로 TTL을 설정했습니다. TTL은 정합성을 보장하기 위한 1차 수단이 아니라, 혹시라도 캐시 갱신 로직이 누락되거나 이벤트가 유실되는 상황에서 오래된 데이터가 무한히 남지 않도록 하는 안전장치 역할을 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">saveProductDetail</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProductDetailInfo</span> productDetailInfo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> key <span class=\"token operator\">=</span> <span class=\"token class-name\">RedisKeyManager</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PRODUCT_DETAIL_KEY</span> <span class=\"token operator\">+</span> productDetailInfo<span class=\"token punctuation\">.</span><span class=\"token function\">getProductId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Duration</span> ttl <span class=\"token operator\">=</span> <span class=\"token class-name\">Duration</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofHours</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> cache <span class=\"token operator\">=</span> objectMapper<span class=\"token punctuation\">.</span><span class=\"token function\">convertValue</span><span class=\"token punctuation\">(</span>productDetailInfo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    objectRedisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> cache<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    objectRedisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">expire</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> ttl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 키 단위 TTL</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TL의 구체적인 값은 정답이 없습니다.\n너무 짧게 잡으면 캐시 미스가 자주 발생해 오히려 DB 부하를 키울 수 있고, 너무 길면 장애 상황에서 잘못된 데이터가 오래 유지될 수 있습니다.\n저는 개인적으로 3시간 정도라면 적당하지 않을까 생각했지만, 이는 어디까지나 제 느낌일 뿐이고, 서비스 트래픽 패턴과 페이지 중요도에 따라 기획자·운영자와 함께 논의해 결정해야 할 부분이라고 봅니다.</p>\n<h2 id=\"ttl이-끝나는-그-순간\" style=\"position:relative;\"><a href=\"#ttl%EC%9D%B4-%EB%81%9D%EB%82%98%EB%8A%94-%EA%B7%B8-%EC%88%9C%EA%B0%84\" aria-label=\"ttl이 끝나는 그 순간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TTL이 끝나는 그 순간</h2>\n<p>TTL을 설정해두고 나니 또 다른 고민이 생겼습니다.<br>\n만약 TTL이 만료되는 순간, 수많은 사용자가 동시에 상품 상세 페이지에 진입한다면 어떻게 될까요?<br>\n캐시는 비어 있고, 모든 요청이 한꺼번에 DB로 향하게 됩니다.<br>\n이 상황을 상상하니, 순식간에 DB I/O가 폭증할 것 같았습니다.</p>\n<p>바로 이것이 <strong>캐시 스탬피드(Cache Stampede)</strong> 문제입니다.</p>\n<p>캐시가 만료되는 그 짧은 순간, 사용자 입장에서는 단순히 캐시 미스일 뿐이지만, 시스템 입장에서는 수백 건의 요청이 동시에 DB에 몰리며 큰 부담을 주는 상황이 벌어집니다.</p>\n<h3 id=\"ttl을-조금-다르게-주자\" style=\"position:relative;\"><a href=\"#ttl%EC%9D%84-%EC%A1%B0%EA%B8%88-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EC%A3%BC%EC%9E%90\" aria-label=\"ttl을 조금 다르게 주자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TTL을 조금 다르게 주자</h3>\n<p>어떻게 해결할 수 있을까 고민하다가, TTL을 조금 다르게 주면 되겠다는 생각이 들었습니다\n.<br>\nTTL을 모두 정확히 3시간으로 설정하면, 비슷한 시각에 만들어진 캐시들이 동시에 만료됩니다.</p>\n<p>그래서 TTL에 <strong>작은 랜덤 값(Jitter)</strong> 을 더해 만료 시점을 분산시켰습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Duration</span> ttl <span class=\"token operator\">=</span> <span class=\"token class-name\">RedisCacheConfig</span><span class=\"token punctuation\">.</span><span class=\"token function\">jitter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Duration</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofHours</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobjectRedisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">expire</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> ttl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>예를 들어 3시간 ± 10% 범위에서 TTL을 주면, 캐시들이 동시에 터지지 않고 시간차를 두고 자연스럽게 재적재됩니다.\n단순하지만 꽤 효과적인 방법이었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisCacheConfig</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Duration</span> <span class=\"token function\">jitter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Duration</span> ttl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> ms <span class=\"token operator\">=</span> ttl<span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> delta <span class=\"token operator\">=</span> <span class=\"token class-name\">ThreadLocalRandom</span><span class=\"token punctuation\">.</span><span class=\"token function\">current</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextLong</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>ms <span class=\"token operator\">/</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> ms <span class=\"token operator\">/</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ±10%</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Duration</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofMillis</span><span class=\"token punctuation\">(</span>ms <span class=\"token operator\">+</span> delta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 메서드를 쓰면 TTL을 지정할 때마다 자동으로 ±10% 범위의 난수를 적용할 수 있어, 스탬피드 위험을 손쉽게 줄일 수 있습니다.</p>\n<h2 id=\"특정-키로-몰리는-트래픽\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A0%95-%ED%82%A4%EB%A1%9C-%EB%AA%B0%EB%A6%AC%EB%8A%94-%ED%8A%B8%EB%9E%98%ED%94%BD\" aria-label=\"특정 키로 몰리는 트래픽 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특정 키로 몰리는 트래픽</h2>\n<p>스탬피드를 Jitter로 막아두니 한숨 돌린 것 같았지만, 또 다른 고민이 생겼습니다.</p>\n<p>이번에는 캐시 만료 시점과 상관없이, 특정 상품 하나에만 트래픽이 몰리는 경우였습니다.</p>\n<p>예를 들어 프로모션 상품이나 초인기 아이템이 있으면, 그 상품의 상세 페이지 캐시에만 수많은 요청이 집중됩니다.<br>\n이런 경우 캐시가 존재하더라도, 캐시를 채우는 과정에서 순간적으로 병목이 생길 수 있습니다.</p>\n<p>이 현상을 <strong>핫키(Hot Key)</strong> 라고 부릅니다.</p>\n<h3 id=\"한-번만-db에-다녀오기\" style=\"position:relative;\"><a href=\"#%ED%95%9C-%EB%B2%88%EB%A7%8C-db%EC%97%90-%EB%8B%A4%EB%85%80%EC%98%A4%EA%B8%B0\" aria-label=\"한 번만 db에 다녀오기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한 번만 DB에 다녀오기</h3>\n<p>핫키 상황에서는 단순히 TTL 분산으로는 부족합니다.<br>\n요청이 동시에 몰릴 때마다 모두 DB를 두드린다면 여전히 부하가 커지기 때문입니다.</p>\n<p>그래서 이때는 <strong>분산 락(Distributed Lock)</strong> 을 사용합니다.<br>\n캐시가 비어 있을 때 여러 요청이 동시에 들어와도, 오직 하나의 요청만 락을 획득해 DB를 조회하고 캐시를 채웁니다.<br>\n나머지 요청들은 잠시 기다렸다가, 갱신된 캐시를 그대로 가져갑니다.</p>\n<p>DB로 향하는 문을 단 하나로 줄여버리는 방식이죠.<br>\n핫키가 발생할 수 있는 인기 상품이나 랭킹 페이지 같은 곳에서는 이 전략이 특히 유용했습니다.</p>\n<h2 id=\"마지막-고민-존재하지-않는-데이터\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%A7%80%EB%A7%89-%EA%B3%A0%EB%AF%BC-%EC%A1%B4%EC%9E%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"마지막 고민 존재하지 않는 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마지막 고민: 존재하지 않는 데이터</h2>\n<p>여기까지 정리하고 나니 또 하나의 상황이 떠올랐습니다.\n존재하지 않는 상품 ID가 계속 조회된다면 어떻게 될까요?\n예를 들어 잘못된 요청이 반복되면, 캐시에는 당연히 없으니 모든 요청이 DB로 향하게 됩니다.\n이건 의도치 않게 캐시를 “뚫고” 들어가는 셈이죠. 이를 <strong>캐시 관통(Cache Penetration)</strong> 이라고 합니다.</p>\n<h3 id=\"캐시-관통-대응-없음도-캐싱하기\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EA%B4%80%ED%86%B5-%EB%8C%80%EC%9D%91-%EC%97%86%EC%9D%8C%EB%8F%84-%EC%BA%90%EC%8B%B1%ED%95%98%EA%B8%B0\" aria-label=\"캐시 관통 대응 없음도 캐싱하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 관통 대응: \"없음\"도 캐싱하기</h3>\n<p>이 문제의 해결책은 단순했습니다.\n**존재하지 않는다(null)**는 사실 자체를 캐싱하는 겁니다.</p>\n<p>DB 조회 결과가 없으면, 특별한 값(예: \"<strong>null</strong>\")을 짧은 TTL과 함께 캐시에 저장합니다.\n그러면 이후의 잘못된 요청은 DB까지 가지 않고 캐시에서 빠르게 차단됩니다.</p>\n<p>짧은 TTL을 주는 이유는, 정말로 데이터가 나중에 생길 수도 있기 때문입니다.</p>\n<h2 id=\"맺으며\" style=\"position:relative;\"><a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\" aria-label=\"맺으며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>맺으며</h2>\n<p>Redis 캐싱을 적용하는 과정은 단순히 \"조회 성능을 높인다\"라는 차원을 넘어섰습니다.</p>\n<ul>\n<li>어떤 데이터를 캐싱할지 고민했고 (<strong><code class=\"language-text\">상품 상세 페이지</code></strong>)</li>\n<li>어떻게 저장할지 선택했고 (<code class=\"language-text\">Hash</code>)</li>\n<li>어떻게 읽을지 정리했고 (<code class=\"language-text\">Cache-Aside</code>)</li>\n<li>언제 비울지 결정했고 (<code class=\"language-text\">DB-First + TTL</code>)</li>\n<li>그리고 운영 중 발생할 수 있는 다양한 문제(<strong><code class=\"language-text\">스탬피드, 핫키, 관통</code></strong>)까지 대비했습니다.</li>\n</ul>\n<p>돌이켜보니 캐시는 단순히 DB를 덜 두드리는 도구가 아니라, 데이터의 성격과 트래픽의 특성을 반영한 아키텍처적 선택이었습니다.</p>\n<p>Redis라는 무기를 다루면서, 저는 캐싱 전략이 결국 <strong>“데이터마다 다른 해답을 내려야 하는 작업”</strong> 이라는 것을 배웠습니다.</p>","timeToRead":6,"frontmatter":{"title":"DB 가 힘들어 해요 : 인덱스를 넘어 레디스 캐싱으로 조회 성능 올리기","summary":null,"date":"2025-09-12","categories":["cache"],"thumbnail":null}}}]}},"pageContext":{"slug":"/redis-caching-in-practice/"}},"staticQueryHashes":[],"slicesMap":{}}