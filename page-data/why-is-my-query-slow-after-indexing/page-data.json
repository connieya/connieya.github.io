{"componentChunkName":"component---src-templates-post-template-tsx","path":"/why-is-my-query-slow-after-indexing/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"tableOfContents":"<ul>\n<li>\n<p><a href=\"#group-by%EA%B0%80-order-by-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EB%A7%89%EB%8A%94-%EC%88%9C%EA%B0%84\">GROUP BY가 ORDER BY 인덱스를 막는 순간</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-price-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%EC%95%88-%ED%83%80%EC%A7%80-group-by%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">왜 price 인덱스가 안 타지? (GROUP BY의 우선순위)</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#a-%EC%B4%88%EA%B8%B0%EB%8A%90%EB%A6%B0-%EA%B2%BD%EB%A1%9C--join--group-by--order-by\">A. 초기(느린) 경로 — JOIN + GROUP BY + ORDER BY</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A8%BC%EC%A0%80-%EC%A4%84%EC%9D%B4%EA%B3%A0-%EB%82%98%EC%A4%91%EC%97%90-%EA%B3%84%EC%82%B0%ED%95%9C%EB%8B%A4-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC--limit-%EC%A0%84%EB%9E%B5\">먼저 줄이고 나중에 계산한다: 서브쿼리 + LIMIT 전략</a></p>\n<ul>\n<li>\n<p><a href=\"#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD%EB%A7%8C-%EC%A0%81%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EC%A0%88%EB%B0%98%EC%9D%98-%EC%84%B1%EA%B3%B5\">구조 변경만 적용했을 때: 절반의 성공</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%8B%9C%EB%84%88%EC%A7%80%EC%9D%98-%EB%B0%9C%ED%98%84\">구조 변경 + 인덱스: 진정한 시너지의 발현</a></p>\n<ul>\n<li><a href=\"#b-%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%84%A0%EC%A0%95%EB%A0%AC%EC%B6%95%EC%86%8C-%ED%9B%84-%EA%B3%84%EC%82%B0%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC\">B. 구조 변경 — “선정렬·축소 후 계산”(서브쿼리)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%8F%84%EC%9E%85\">읽기 전용 집계 테이블 (비정규화) 도입</a></p>\n<ul>\n<li>\n<p><a href=\"#%EA%B0%80%EA%B2%A9%EC%88%9C-%EC%A0%95%EB%A0%AC-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%84%B1%EB%8A%A5-%ED%99%95%EC%9D%B8\">가격순 정렬: 새로운 모델의 기본 성능 확인</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%95%84%EC%9A%94%EC%88%9C-%EC%A0%95%EB%A0%AC-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%8B%9C%ED%97%98%EB%8C%80\">좋아요순 정렬: 비정규화 모델의 진짜 시험대</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%88%9C%EC%A7%84%ED%95%9C-%EA%B8%B0%EB%8C%80\">단일 인덱스의 순진한 기대</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EB%B0%B0%EC%8B%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%98%EB%AC%B8\">복합 인덱스의 배신, 그리고 의문</a></p>\n</li>\n<li>\n<p><a href=\"#driving-table%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4-003%EC%B4%88%EA%B0%80-%EB%B3%B4%EC%9D%B8%EB%8B%A4\">Driving Table을 바꾸면 0.03초가 보인다</a></p>\n</li>\n<li>\n<p><a href=\"#straight_join%EC%9C%BC%EB%A1%9C-%EC%A1%B0%EC%9D%B8-%EC%88%9C%EC%84%9C-%EA%B3%A0%EC%A0%95-mysql\">STRAIGHT_JOIN으로 조인 순서 고정 (MySQL)</a></p>\n<ul>\n<li><a href=\"#c-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94--%EC%98%AC%EB%B0%94%EB%A5%B8-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99-%ED%85%8C%EC%9D%B4%EB%B8%94\">C. 집계 테이블 + 올바른 드라이빙 테이블</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%B1%EB%8A%A5%EA%B3%BC-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%82%AC%EC%9D%B4%EC%97%90%EC%84%9C\">성능과 비즈니스 요구사항 사이에서</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8A%9C%EB%8B%9D-%EC%97%AC%EC%A0%95-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EA%B8%B0\">튜닝 여정 한눈에 보기</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\">맺으며</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%8A%94-%EA%B0%90%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%9C%EB%8B%A4\">인덱스는 감이 아닌 데이터로 설계한다.</a></li>\n</ul>\n</li>\n</ul>","html":"<p>이커머스 서비스에서 가격, 최신순, 인기순으로 상품 목록을 보여주는 것은 지극히 평범하고도 필수적인 기능이다</p>\n<p>개발 단계의 적은 데이터에서는 드러나지 않는 성능 병목을 확인하기 위해, 의미 있는 규모의 테스트 데이터(상품 50만, 좋아요 10만)를 채워 넣고 마지막 관문인 성능 테스트를 시작했다.</p>\n<p>이때 가장 중요한 것은 정확한 병목 지점을 찾는 것이었다. 여러 사용자로 테스트하면 네트워크나 서버 경합 등 다른 변수가 섞일 수 있기에, 변인 통제를 위해 오직 가상 사용자 1명(1 VU)으로 1분간 API를 반복 호출하여 순수한 API 처리 성능의 베이스라인을 측정하기로 했다.</p>\n<p>측정 결과 평균 응답 시간이 10초를 훌쩍 넘는 믿기 힘든 결과가 나왔다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ee3d92b396628c12098904d31a69412b/58a83/k6test.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.45833333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVR42pWRWw6DIBBF3YgggsgrPmKbdP8bu71QmhC1H/04ISPheGemC3HBuh0YlIGQIwZtIYkYdKn/pZtmj+15QFuKBgpZSyLqD3qhIEg++76elXuh84j7AhsC002Q/FhgwsxoPfQcGj61IaWTs9D5hON4YXYJapxK6y06JJi0QPtIEXGUFSKkoVCchDGt2PYHH38SnYXKzFAUKCbL81UNcjTXhFm4cCllISdZwToIU5fUzvPXDHObmim+M7vAe6nqxrO05Ub4Bjq6xEfNRg6xAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/ee3d92b396628c12098904d31a69412b/a59e9/k6test.webp 192w,\n/static/ee3d92b396628c12098904d31a69412b/0ca9f/k6test.webp 384w,\n/static/ee3d92b396628c12098904d31a69412b/dc9b9/k6test.webp 768w,\n/static/ee3d92b396628c12098904d31a69412b/e2c2f/k6test.webp 1152w,\n/static/ee3d92b396628c12098904d31a69412b/f952e/k6test.webp 1488w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/ee3d92b396628c12098904d31a69412b/3b721/k6test.png 192w,\n/static/ee3d92b396628c12098904d31a69412b/66595/k6test.png 384w,\n/static/ee3d92b396628c12098904d31a69412b/fe486/k6test.png 768w,\n/static/ee3d92b396628c12098904d31a69412b/d2d74/k6test.png 1152w,\n/static/ee3d92b396628c12098904d31a69412b/58a83/k6test.png 1488w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/ee3d92b396628c12098904d31a69412b/fe486/k6test.png\"\n            alt=\"alt text\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>DB 클라이언트에서 직접 쿼리를 실행해 보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5.38</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>단 5개의 데이터를 가져오는 데 5초 이상이 소요되고 있었다.</p>\n<p>문제의 원인을 찾기 위해 곧바로 쿼리 분석에 들어갔다.</p>\n<h2 id=\"group-by가-order-by-인덱스를-막는-순간\" style=\"position:relative;\"><a href=\"#group-by%EA%B0%80-order-by-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EB%A7%89%EB%8A%94-%EC%88%9C%EA%B0%84\" aria-label=\"group by가 order by 인덱스를 막는 순간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GROUP BY가 ORDER BY 인덱스를 막는 순간</h2>\n<p>가장 먼저 의심한 곳은 product_like 테이블과 JOIN하여 좋아요 수를 집계하는 GROUP BY 구문이었다.</p>\n<p>처음 쿼리를 설계할 때는 여러 번 쿼리를 날리는 서브쿼리보다, 단일 쿼리로 모든 정보를 가져오는 JOIN 방식이 더 효율적일 것이라는 막연한 믿음이 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    p<span class=\"token punctuation\">.</span>id\n     <span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">.</span>price\n     <span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">.</span>name\n     <span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">.</span>name\n     <span class=\"token punctuation\">,</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span>pl<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> likeCount\n     <span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>released_at <span class=\"token keyword\">FROM</span>\n    product p\n        <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> brand b <span class=\"token keyword\">ON</span> b<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>ref_brand_id\n        <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span>  product_like pl <span class=\"token keyword\">ON</span> p<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> pl<span class=\"token punctuation\">.</span>ref_product_id\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span>\n    p<span class=\"token punctuation\">.</span>id\n       <span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>price\n       <span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">.</span>name\n       <span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>name\n       <span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>released_at\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> p<span class=\"token punctuation\">.</span>price <span class=\"token keyword\">ASC</span>\n    <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>EXPLAIN으로 실행 계획을 확인하자, 나의 믿음이 어떻게 잘못되었는지 명확하게 드러났다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>                         <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------------|-------|-------|-----------------------------|--------|---------------------------------------------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>   <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>                        <span class=\"token operator\">|</span> <span class=\"token number\">497193</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref<span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                     <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> pl    <span class=\"token operator\">|</span> <span class=\"token keyword\">index</span> <span class=\"token operator\">|</span> UKi88ydvxuyj9djsf1yaq18mdpb  <span class=\"token operator\">|</span> <span class=\"token number\">99822</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">where</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">join</span> buffer <span class=\"token punctuation\">(</span><span class=\"token keyword\">hash</span> <span class=\"token keyword\">join</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<ul>\n<li><strong>type: ALL</strong> : product 테이블을 풀 스캔하고 있다. 인덱스를 전혀 활용하지 못하고 50만 건의 데이터를 모두 읽고 있다는 의미다.</li>\n<li><strong>Extra: Using temporary; Using filesort</strong> : 성능 저하의 주범이다. <code class=\"language-text\">GROUP BY</code>와 <code class=\"language-text\">ORDER BY</code>를 함께 처리하기 위해, 데이터베이스는 조인과 집계가 끝난 거대한 중간 결과물을 임시 테이블에 저장(<code class=\"language-text\">Using temporary</code>)한 뒤, 이 임시 테이블을 다시 정렬(<code class=\"language-text\">Using filesort</code>)하는 최악의 시나리오로 동작하고 있었다. LIMIT 5는 이 모든 비효율적인 작업이 끝난 후에야 적용된다.</li>\n</ul>\n<h2 id=\"왜-price-인덱스가-안-타지-group-by의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%99%9C-price-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%EC%95%88-%ED%83%80%EC%A7%80-group-by%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"왜 price 인덱스가 안 타지 group by의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 price 인덱스가 안 타지? (GROUP BY의 우선순위)</h2>\n<p>\"풀 스캔과 filesort가 문제라면, 정렬 컬럼에 인덱스를 걸면 해결될 것이다.\"</p>\n<p>가장 단순하고 명쾌한 해결책이라고 생각했다. <code class=\"language-text\">ORDER BY</code>의 대상인 product 테이블 price 컬럼에 B-Tree 인덱스를 생성했다.</p>\n<p>이제 옵티마이저가 당연히 이 인덱스를 타고 filesort를 건너뛸 것이라고 확신했다. 그리고 다시 쿼리를 실행했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5.35</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>결과는 처참했다. <code class=\"language-text\">5.38초</code>가 <code class=\"language-text\">5.35초</code> 가 된 것은 오차 범위일 뿐, 아무것도 해결되지 않았다. 당혹스러운 마음에 다시 실행 계획을 확인했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+-----------------------------------+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra                             <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+-----------------------------------+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>  <span class=\"token operator\">|</span> <span class=\"token number\">497349</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort   <span class=\"token operator\">|</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre></div>\n<p>변한 것이 아무것도 없었다. product 테이블은 여전히 type: ALL로 풀 스캔되고 있었고, Extra에는 Using filesort가 선명하게 남아있었다.</p>\n<p>인덱스를 분명히 만들었는데, 왜 데이터베이스는 사용조차 하지 않는 걸까?</p>\n<p>이유는 데이터베이스의 실행 순서에 있었다.</p>\n<p>옵티마이저는 <code class=\"language-text\">ORDER BY</code> 절을 처리하기 전에, <code class=\"language-text\">GROUP BY</code> 절을 먼저 수행하여 likeCount를 계산해야 한다.</p>\n<p>이 집계 연산은 테이블의 전체 데이터를 대상으로 할 수밖에 없으므로, 옵티마이저는 price 인덱스를 사용하여 5개만 미리 뽑아내는 최적화를 포기해버린다.</p>\n<p>결국 옵티마이저는 다음과 같은 순서로 동작한다.</p>\n<ol>\n<li>50만 개 상품 전체를 <code class=\"language-text\">JOIN</code>, <code class=\"language-text\">GROUP BY</code> 하여 likeCount가 포함된 거대한 임시 테이블 생성</li>\n<li>이 인덱스가 없는 임시 테이블을 price 기준으로 정렬</li>\n<li>price 인덱스는 원본 테이블에만 존재할 뿐, 이 임시 테이블에는 없으므로 무용지물</li>\n</ol>\n<p>이 비효율적인 과정을 도식으로 표현하면 다음과 같다</p>\n<h4 id=\"a-초기느린-경로--join--group-by--order-by\" style=\"position:relative;\"><a href=\"#a-%EC%B4%88%EA%B8%B0%EB%8A%90%EB%A6%B0-%EA%B2%BD%EB%A1%9C--join--group-by--order-by\" aria-label=\"a 초기느린 경로  join  group by  order by permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A. 초기(느린) 경로 — JOIN + GROUP BY + ORDER BY</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">product <span class=\"token punctuation\">(</span><span class=\"token keyword\">Full</span> scan: <span class=\"token number\">50</span>만<span class=\"token punctuation\">)</span>\n   └─ <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> product_like\n         └─ <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> <span class=\"token punctuation\">(</span>임시 테이블 생성<span class=\"token punctuation\">)</span>\n               └─ <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> price <span class=\"token punctuation\">(</span><span class=\"token keyword\">Using</span> filesort<span class=\"token punctuation\">)</span>\n                     └─ <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span></code></pre></div>\n<p>JOIN 자체의 성능 문제일까 싶어,</p>\n<p>이번에는 product_like 테이블의 ref_product_id 컬럼에도 인덱스를 추가한 뒤\n실행 계획을 확인 해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+---------------------------------+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra                           <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+---------------------------------+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>  <span class=\"token operator\">|</span> <span class=\"token number\">497349</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">|</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>         <span class=\"token operator\">|</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>   <span class=\"token operator\">|</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>    <span class=\"token operator\">|</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> pl    <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span>                     <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+---------------------------------+</span></code></pre></div>\n<p>product_like 테이블의 실행 계획이 type: index에서 type: ref로 개선되며 조인 자체는 빨라졌다.</p>\n<p>하지만 가장 큰 문제인 product 테이블의 type: ALL과 Using filesort는 조금도 변하지 않았다.</p>\n<p>쿼리 시간은 여전히 5초대에 머물렀다. GROUP BY 절은 ORDER BY 절보다 먼저 실행되어 테이블 전체를 대상으로 집계 연산을 수행해야 한다. 이 과정에서 생성되는 임시 테이블에는 price 인덱스가 없으므로, 결국 ORDER BY를 위한 인덱스 최적화는 원천적으로 불가능했다.</p>\n<h2 id=\"먼저-줄이고-나중에-계산한다-서브쿼리--limit-전략\" style=\"position:relative;\"><a href=\"#%EB%A8%BC%EC%A0%80-%EC%A4%84%EC%9D%B4%EA%B3%A0-%EB%82%98%EC%A4%91%EC%97%90-%EA%B3%84%EC%82%B0%ED%95%9C%EB%8B%A4-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC--limit-%EC%A0%84%EB%9E%B5\" aria-label=\"먼저 줄이고 나중에 계산한다 서브쿼리  limit 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>먼저 줄이고 나중에 계산한다: 서브쿼리 + LIMIT 전략</h2>\n<p>GROUP BY라는 거대한 벽 앞에서 인덱스가 무력해지는 것을 확인한 나는, 문제 해결의 방향을 완전히 틀어야 했다. 인덱스 튜닝이 아니라, 쿼리 구조 자체를 변경하기로 결심했다.</p>\n<p>나는 GROUP BY를 제거하고, likeCount를 SELECT 절의 스칼라 서브쿼리로 가져오는 방식으로 쿼리를 수정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 최적화된 쿼리 (스칼라 서브쿼리)</span>\n<span class=\"token keyword\">SELECT</span>\n    p<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> product_like pl <span class=\"token keyword\">WHERE</span> pl<span class=\"token punctuation\">.</span>ref_product_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> likeCount<span class=\"token punctuation\">,</span>\n    p<span class=\"token punctuation\">.</span>released_at\n<span class=\"token keyword\">FROM</span> product p\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> brand b <span class=\"token keyword\">ON</span> b<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>ref_brand_id\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> p<span class=\"token punctuation\">.</span>price <span class=\"token keyword\">ASC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"구조-변경만-적용했을-때-절반의-성공\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD%EB%A7%8C-%EC%A0%81%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EC%A0%88%EB%B0%98%EC%9D%98-%EC%84%B1%EA%B3%B5\" aria-label=\"구조 변경만 적용했을 때 절반의 성공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구조 변경만 적용했을 때: 절반의 성공</h3>\n<p>먼저, product 테이블의 모든 인덱스를 제거하고 순수하게 쿼리 구조 변경의 효과만 확인해 보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.63</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">5.38초</code>에 비하면 엄청난 발전이다. 8배 이상 빨라졌다. GROUP BY를 제거한 것만으로도 상당한 성능 개선이 이루어진 것이다.</p>\n<p>하지만 <code class=\"language-text\">0.63초</code> 역시 만족스러운 속도는 아니었다. EXPLAIN을 통해 그 이유를 파헤쳐 보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+----------------+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra          <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+------+---------+----------------+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>     <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>  <span class=\"token operator\">|</span> <span class=\"token number\">497193</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> filesort <span class=\"token operator\">|</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">type: ALL</code> 및 <code class=\"language-text\">Extra: Using filesort</code> : 여전히 product 테이블은 풀 스캔되고 있었고, filesort가 발생하고 있었다. price 인덱스가 없으니 당연한 결과다.</li>\n<li>달라진 점: 이전과 달리, <code class=\"language-text\">Using temporary</code>가 사라졌다. GROUP BY가 없어지면서 거대한 임시 테이블을 만들 필요가 없어졌고, filesort의 대상도 JOIN과 집계가 포함된 복잡한 결과가 아닌 product 테이블 자체로 단순화되었다.<br/> 이것이 <code class=\"language-text\">5.38초</code>가 <code class=\"language-text\">0.63초</code>로 줄어든 핵심 이유다.</li>\n</ul>\n<p>구조 변경은 temporary table이라는 가장 무거운 족쇄 하나를 풀어주었지만, filesort라는 족쇄는 여전히 남아있었다.</p>\n<h3 id=\"구조-변경--인덱스-진정한-시너지의-발현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%8B%9C%EB%84%88%EC%A7%80%EC%9D%98-%EB%B0%9C%ED%98%84\" aria-label=\"구조 변경  인덱스 진정한 시너지의 발현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구조 변경 + 인덱스: 진정한 시너지의 발현</h3>\n<p>이제 이 새로운 쿼리 구조에 날개를 달아줄 차례다. product(price) 컬럼에 다시 인덱스를 생성했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.06</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>결과는 경이로웠다. <code class=\"language-text\">0.63초</code>가 <code class=\"language-text\">0.06</code>초로, 다시 10배 이상 빨라졌다.</p>\n<p>JOIN과 GROUP BY가 있던 시절과 비교하면 거의 90배에 가까운 성능 향상이다. EXPLAIN은 이 극적인 변화의 이유를 명확하게 보여주었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+-------+-----------+------+-------+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>       <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">|</span> Extra <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">----+-------------+-------+-------+-----------+------+-------+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>     <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">index</span> <span class=\"token operator\">|</span> idx_price <span class=\"token operator\">|</span>    <span class=\"token number\">5</span> <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>  <span class=\"token operator\">|</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<ul>\n<li><strong><code class=\"language-text\">type: index</code></strong>: <code class=\"language-text\">ALL</code>이 <code class=\"language-text\">index</code>로 바뀌었다. 이제 옵티마이저는 <code class=\"language-text\">price</code> 인덱스를 보고 테이블 전체를 읽는 대신, 인덱스만 읽어서 처리한다.</li>\n</ul>\n<ul>\n<li><strong><code class=\"language-text\">rows: 5</code></strong>: 처리할 예상 행 수가 50만에서 단 5로 줄었다. <code class=\"language-text\">ORDER BY</code>와 <code class=\"language-text\">LIMIT</code>을 보고, 필요한 만큼만 읽으면 된다는 것을 완벽하게 인지한 것이다.</li>\n<li><strong><code class=\"language-text\">Extra: NULL</code></strong>: 마침내 <strong><code class=\"language-text\">Using filesort</code>가 사라졌다.</strong> 인덱스 자체가 이미 <code class=\"language-text\">price</code> 순으로 정렬되어 있으므로, 별도의 정렬 작업이 전혀 필요 없어진 것이다.</li>\n</ul>\n<p>이전의 <code class=\"language-text\">JOIN</code>은 <strong>\"선 계산, 후 정렬\"</strong> 방식으로 50만 개 전체를 대상으로 무거운 작업을 했다면, 서브쿼리 방식은 <strong>\"선 정렬 및 범위 축소, 후계산\"</strong> 방식으로 동작했다.</p>\n<p>즉, <code class=\"language-text\">ORDER BY</code>와 <code class=\"language-text\">LIMIT</code>으로 5개의 대상을 먼저 추려낸 뒤, 그 5개에 대해서만 서브쿼리를 실행하여 작업의 총량을 극적으로 줄인 것이다.</p>\n<p><strong>좋은 쿼리 구조(서브쿼리)와 좋은 인덱스(<code class=\"language-text\">price</code>)가 만났을 때 비로소 최적의 성능이 나온다는 것</strong>을 데이터로 증명한 순간이었다.</p>\n<h4 id=\"b-구조-변경--선정렬축소-후-계산서브쿼리\" style=\"position:relative;\"><a href=\"#b-%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD--%EC%84%A0%EC%A0%95%EB%A0%AC%EC%B6%95%EC%86%8C-%ED%9B%84-%EA%B3%84%EC%82%B0%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC\" aria-label=\"b 구조 변경  선정렬축소 후 계산서브쿼리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B. 구조 변경 — “선정렬·축소 후 계산”(서브쿼리)</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">\nproduct\n  └─ <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> price <span class=\"token punctuation\">(</span>인덱스 가능<span class=\"token punctuation\">)</span>\n       └─ <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">(</span>상위 <span class=\"token number\">5</span>개<span class=\"token punctuation\">)</span>\n            └─ 각 행마다 <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> product_like <span class=\"token keyword\">WHERE</span> ref_product_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"읽기-전용-집계-테이블-비정규화-도입\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%8F%84%EC%9E%85\" aria-label=\"읽기 전용 집계 테이블 비정규화 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽기 전용 집계 테이블 (비정규화) 도입</h2>\n<p>서브쿼리 방식은 훌륭했지만, 조회할 때마다 Count 를 계산하는 작업이 마음에 걸렸다. 읽기 성능을 극한으로 끌어올리기 위해,\n나는 비정규화를 도입하기로 결정했다.</p>\n<p>'좋아요' 이벤트가 발생할 때 마다 집계된 like_count 를 저장하는 like_summary 테이블을 별도로 만들었다.</p>\n<p>이제 조회 쿼리는 실시간 집계 없이, 미리 계산된 값을 join 으로 가져오기만 하면 된다.</p>\n<p>이 새로운 모델이 기존의 '가격순 정렬'에서도 문제없이 동작하는지 먼저 확인하고, 그 다음 이 모델의 진짜 목적인 '좋아요순 정렬'의 성능을 확인해 보기로 했다</p>\n<h3 id=\"가격순-정렬-새로운-모델의-기본-성능-확인\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EA%B2%A9%EC%88%9C-%EC%A0%95%EB%A0%AC-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%84%B1%EB%8A%A5-%ED%99%95%EC%9D%B8\" aria-label=\"가격순 정렬 새로운 모델의 기본 성능 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가격순 정렬: 새로운 모델의 기본 성능 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 비정규화 모델 쿼리</span>\n<span class=\"token keyword\">SELECT</span>\n    p<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>name <span class=\"token keyword\">AS</span> brandName<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">COALESCE</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>like_count<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> likeCount<span class=\"token punctuation\">,</span>\n    p<span class=\"token punctuation\">.</span>released_at\n<span class=\"token keyword\">FROM</span> product p\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> brand b <span class=\"token keyword\">ON</span> p<span class=\"token punctuation\">.</span>ref_brand_id <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> like_summary s <span class=\"token keyword\">ON</span> s<span class=\"token punctuation\">.</span>target_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>target_type <span class=\"token operator\">=</span> <span class=\"token string\">'PRODUCT'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> p<span class=\"token punctuation\">.</span>price <span class=\"token keyword\">DESC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>먼저 기존과 동일하게 price로 정렬하는 쿼리를 테스트했다. product(price) 인덱스가 있는 상태에서 실행 시간은 <code class=\"language-text\">0.05초</code>로,\n이전 서브쿼리 모델과 비슷하거나 미세하게 더 빠른 결과를 보였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.05</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>실행 계획은 다음과 같이 filesort 없이 완벽하게 동작했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>   <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>       <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------|--------|-----------|------|-----------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">index</span>  <span class=\"token operator\">|</span> idx_price <span class=\"token operator\">|</span> <span class=\"token number\">5</span>    <span class=\"token operator\">|</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>   <span class=\"token operator\">|</span> <span class=\"token number\">1</span>    <span class=\"token operator\">|</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> s     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> UK<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>     <span class=\"token operator\">|</span> <span class=\"token number\">1</span>    <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span> condition\n</code></pre></div>\n<p>옵티마이저가 product 테이블의 idx_price를 타고, brand와 like_summary는 이미 존재하는 인덱스를 통해 효율적으로 조인하고 있었다.</p>\n<p>실시간 집계의 부하가 사라진 덕분에 안정적인 성능을 보여주었다.</p>\n<h3 id=\"좋아요순-정렬-비정규화-모델의-진짜-시험대\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%95%84%EC%9A%94%EC%88%9C-%EC%A0%95%EB%A0%AC-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%8B%9C%ED%97%98%EB%8C%80\" aria-label=\"좋아요순 정렬 비정규화 모델의 진짜 시험대 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋아요순 정렬: 비정규화 모델의 진짜 시험대</h3>\n<p>이제 이 모델을 도입한 진짜 이유, <strong>'좋아요순 정렬'</strong> 을 테스트할 차례다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 비정규화 모델 쿼리</span>\n<span class=\"token keyword\">SELECT</span>\n    p<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>name <span class=\"token keyword\">AS</span> brandName<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">COALESCE</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>like_count<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> likeCount<span class=\"token punctuation\">,</span>\n    p<span class=\"token punctuation\">.</span>released_at\n<span class=\"token keyword\">FROM</span> product p\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> brand b <span class=\"token keyword\">ON</span> p<span class=\"token punctuation\">.</span>ref_brand_id <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> like_summary s <span class=\"token keyword\">ON</span> s<span class=\"token punctuation\">.</span>target_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id <span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>target_type <span class=\"token operator\">=</span> <span class=\"token string\">'PRODUCT'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> s<span class=\"token punctuation\">.</span>like_count <span class=\"token keyword\">DESC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>'좋아요순' 정렬을 테스트하자, 쿼리 시간은 <code class=\"language-text\">1.92초</code>. 다시 원점으로 돌아온 듯했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>                         <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------------|-------|-------|-----------------------------|--------|---------------------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>   <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>                        <span class=\"token operator\">|</span> <span class=\"token number\">497349</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref<span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                     <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> s     <span class=\"token operator\">|</span> eq_ref<span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span> condition\n</code></pre></div>\n<p>EXPLAIN 을 확인하니, 또 다시 product 테이블을 풀 스캔하면 <strong><code class=\"language-text\">Using filesort</code></strong> 가 발생하고 있었다.</p>\n<p>like_summary 테이블에는 (target_id , target_type) 인덱스가 잘 걸려 있었지만 , 정렬 기준인 like_count 컬럼에는 인덱스가 없었다.</p>\n<h3 id=\"단일-인덱스의-순진한-기대\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%88%9C%EC%A7%84%ED%95%9C-%EA%B8%B0%EB%8C%80\" aria-label=\"단일 인덱스의 순진한 기대 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 인덱스의 순진한 기대</h3>\n<p>가장 먼저 떠오르는 해결책은 단순했다.</p>\n<p>like_summary 테이블의 like_count 컬럼에 단일 인덱스를 추가하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">Table</span>        <span class=\"token operator\">|</span> Key_name                    <span class=\"token operator\">|</span> Column_name <span class=\"token operator\">|</span> Cardinality <span class=\"token operator\">|</span> Index_type\n<span class=\"token comment\">-------------|-----------------------------|-------------|-------------|-----------</span>\nlike_summary <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                     <span class=\"token operator\">|</span> id          <span class=\"token operator\">|</span> <span class=\"token number\">430750</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\nlike_summary <span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> target_id   <span class=\"token operator\">|</span> <span class=\"token number\">430750</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\nlike_summary <span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> target_type <span class=\"token operator\">|</span> <span class=\"token number\">430750</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\nlike_summary <span class=\"token operator\">|</span> idx_like_count              <span class=\"token operator\">|</span> like_count  <span class=\"token operator\">|</span> <span class=\"token number\">11</span>          <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\n</code></pre></div>\n<p>이제 옵티마이저가 이 인덱스를 타고 filesort를 피할 것이라고 기대했다. 하지만 결과는 나를 비웃는 듯했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">5</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.86</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>실행 시간은 거의 그대로였고, 실행 계획 역시 이전과 100% 동일했다. 옵티마이저는 내가 만든 idx_like_count를 완전히 무시했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>                         <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------------|-------|-------|-----------------------------|--------|---------------------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>   <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>                        <span class=\"token operator\">|</span> <span class=\"token number\">497349</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref<span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                     <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> <span class=\"token keyword\">SIMPLE</span>      <span class=\"token operator\">|</span> s     <span class=\"token operator\">|</span> eq_ref<span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span> condition\n</code></pre></div>\n<p>왜일까? 옵티마이저는 '비용(Cost)' 기반으로 생각한다.</p>\n<p>이 쿼리에는 s.target_type = 'PRODUCT'라는 숨겨진 필터 조건이 있다.</p>\n<p>옵티마이저 입장에서 idx_like_count만 사용하면, 'PRODUCT' 타입이 아닌 다른 타입의 데이터까지 모두 읽은 뒤에 필터링해야 하는 비효율이 발생할 수 있다.</p>\n<p>결국 옵티마이저는 \"그렇게 하느니 차라리 product 테이블 전체를 읽고 정렬하는 게 낫겠다\"고 판단해버린 것이다.</p>\n<h3 id=\"복합-인덱스의-배신-그리고-의문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EB%B0%B0%EC%8B%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%98%EB%AC%B8\" aria-label=\"복합 인덱스의 배신 그리고 의문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복합 인덱스의 배신, 그리고 의문</h3>\n<p>\"아, 필터링 조건도 함께 넣어줘야 하는구나!\"</p>\n<p>나는 필터링(target_type)과 정렬(like_count)을 모두 포함하는 복합 인덱스를 생성했다.</p>\n<p>이것이야말로 정답이라고 확신했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">Table</span>         <span class=\"token operator\">|</span> Key_name                     <span class=\"token operator\">|</span> <span class=\"token keyword\">Column</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>            <span class=\"token operator\">|</span> Non_unique <span class=\"token operator\">|</span> Cardinality <span class=\"token operator\">|</span> Index_type\n<span class=\"token comment\">--------------|------------------------------|---------------------|------------|------------|-----------</span>\nlike_summary  <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                      <span class=\"token operator\">|</span> id                  <span class=\"token operator\">|</span> <span class=\"token number\">0</span>          <span class=\"token operator\">|</span> <span class=\"token number\">430750</span>     <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\nlike_summary  <span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> target_id<span class=\"token punctuation\">,</span> target_type <span class=\"token operator\">|</span> <span class=\"token number\">0</span>       <span class=\"token operator\">|</span> <span class=\"token number\">430750</span>     <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\nlike_summary  <span class=\"token operator\">|</span> idx_target_type_like_count   <span class=\"token operator\">|</span> target_type<span class=\"token punctuation\">,</span> like_count <span class=\"token operator\">|</span> <span class=\"token number\">1</span>       <span class=\"token operator\">|</span> <span class=\"token number\">11</span>         <span class=\"token operator\">|</span> <span class=\"token keyword\">BTREE</span>\n</code></pre></div>\n<p>하지만 결과는 다시 한번 나를 좌절시켰다. 실행 시간은 <code class=\"language-text\">1.84초</code>,</p>\n<p>실행 계획은 여전히 product 테이블을 풀 스캔하며 Using filesort를 수행하고 있었다</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>   <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>                         <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span> <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------|--------|-----------------------------|------|-------------------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> <span class=\"token keyword\">ALL</span>    <span class=\"token operator\">|</span> <span class=\"token boolean\">NULL</span>                        <span class=\"token operator\">|</span> <span class=\"token number\">497349</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">temporary</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">Using</span> filesort\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                     <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> s     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> UKaqw1do2xdd90a3o0aneikiq8y <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">index</span> condition\n</code></pre></div>\n<p>분명히 쿼리의 모든 조건을 만족하는 완벽한 인덱스를 만들었는데, 왜 옵티마이저는 계속해서 가장 비효율적인 길을 고집하는 걸까?</p>\n<p>여기서 나는 문제의 본질이 인덱스 자체가 아니라, 데이터베이스가 일하는 방식에 있음을 깨달았다.</p>\n<h3 id=\"driving-table을-바꾸면-003초가-보인다\" style=\"position:relative;\"><a href=\"#driving-table%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4-003%EC%B4%88%EA%B0%80-%EB%B3%B4%EC%9D%B8%EB%8B%A4\" aria-label=\"driving table을 바꾸면 003초가 보인다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Driving Table을 바꾸면 0.03초가 보인다</h3>\n<p>해답은 <code class=\"language-text\">Driving Table</code> 과 <code class=\"language-text\">Driven Table</code> 개념에 있었다.</p>\n<p>JOIN 시 가장 먼저 읽는 기준 테이블이 <code class=\"language-text\">Driving Table</code> 이고, 그 결과에 따라 나중에 참조되는 테이블이 <code class=\"language-text\">Driven Table</code> 이다.\nJOIN 성능은 얼마나 작은 <code class=\"language-text\">Driving Table</code> 을 가지고 시작하는 가에 달려 있다.</p>\n<p>옵티마이저는 FROM product p ... 구문을 보고, 50만 건의 product 테이블을 <code class=\"language-text\">Driving Table</code>로 선택하고 있었다.</p>\n<p>즉, 50만 번의 루프를 돌며 like_summary를 찾아 붙인 뒤, 이 거대한 결과물을 통째로 정렬하고 있었던 것이다.</p>\n<p>이 방식에서는 like_summary에 만든 그 어떤 인덱스도 정렬에 사용될 수 없다.</p>\n<p>우리가 원했던 이상적인 순서는 그 반대였다.</p>\n<ol>\n<li><code class=\"language-text\">Driving Table</code>: like_summary에서 like_count가 높은 5개를 인덱스를 이용해 먼저 찾는다.</li>\n<li><code class=\"language-text\">Driven Table</code>: 찾아낸 5개를 가지고 product 테이블을 조인한다.</li>\n</ol>\n<h3 id=\"straight_join으로-조인-순서-고정-mysql\" style=\"position:relative;\"><a href=\"#straight_join%EC%9C%BC%EB%A1%9C-%EC%A1%B0%EC%9D%B8-%EC%88%9C%EC%84%9C-%EA%B3%A0%EC%A0%95-mysql\" aria-label=\"straight_join으로 조인 순서 고정 mysql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STRAIGHT_JOIN으로 조인 순서 고정 (MySQL)</h3>\n<p>옵티마이저가 product 테이블을 Driving Table로 선택하는 것을 막기 위해, JOIN 순서를 직접 제어할 필요가 있었다. FROM 절의 테이블 순서를 변경하고 STRAIGHT_JOIN 힌트를 사용하여, like_summary 테이블부터 조인이 시작되도록 쿼리를 수정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span>\n    like_summary s\nSTRAIGHT_JOIN <span class=\"token comment\">-- 이 힌트로 JOIN 순서를 고정!</span>\n    product p <span class=\"token keyword\">ON</span> s<span class=\"token punctuation\">.</span>target_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span>\n    brand b <span class=\"token keyword\">ON</span> p<span class=\"token punctuation\">.</span>ref_brand_id <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">WHERE</span>\n    s<span class=\"token punctuation\">.</span>target_type <span class=\"token operator\">=</span> <span class=\"token string\">'PRODUCT'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n    s<span class=\"token punctuation\">.</span>like_count <span class=\"token keyword\">DESC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>결과는 완벽했다. <code class=\"language-text\">1.84초</code> 걸리던 쿼리가 <code class=\"language-text\">0.03초</code>로 단축되었다. 실행 계획 또한 의도했던 대로 변경된 것을 확인할 수 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">id <span class=\"token operator\">|</span> <span class=\"token keyword\">table</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">type</span>   <span class=\"token operator\">|</span> <span class=\"token keyword\">key</span>                        <span class=\"token operator\">|</span> <span class=\"token keyword\">rows</span>   <span class=\"token operator\">|</span> Extra\n<span class=\"token comment\">---|-------|--------|----------------------------|--------|--------------------------------</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> s     <span class=\"token operator\">|</span> ref    <span class=\"token operator\">|</span> idx_target_type_like_count <span class=\"token operator\">|</span> <span class=\"token number\">215375</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">Using</span> <span class=\"token keyword\">where</span><span class=\"token punctuation\">;</span> Backward <span class=\"token keyword\">index</span> scan\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> p     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                    <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span>\n<span class=\"token number\">1</span>  <span class=\"token operator\">|</span> b     <span class=\"token operator\">|</span> eq_ref <span class=\"token operator\">|</span> <span class=\"token keyword\">PRIMARY</span>                    <span class=\"token operator\">|</span> <span class=\"token number\">1</span>      <span class=\"token operator\">|</span>\n\n</code></pre></div>\n<ul>\n<li><code class=\"language-text\">Driving Table</code> : 시작 테이블이 like_summary(s)로 변경되었다.</li>\n<li><code class=\"language-text\">Extra: Backward index scan: filesort</code> 가 사라졌다. 옵티마이저는 우리가 만든 idx_target_type_like_count 복합 인덱스를 뒤에서부터 거꾸로 읽어, 정렬 작업을 하지 않고도 DESC 정렬을 완벽하게 구현했다.</li>\n</ul>\n<br/>\n<h4 id=\"c-집계-테이블--올바른-드라이빙-테이블\" style=\"position:relative;\"><a href=\"#c-%EC%A7%91%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94--%EC%98%AC%EB%B0%94%EB%A5%B8-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99-%ED%85%8C%EC%9D%B4%EB%B8%94\" aria-label=\"c 집계 테이블  올바른 드라이빙 테이블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>C. 집계 테이블 + 올바른 드라이빙 테이블</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">\nlike_summary <span class=\"token punctuation\">(</span>idx: target_type<span class=\"token punctuation\">,</span> like_count<span class=\"token punctuation\">)</span>  ← 역방향 인덱스 스캔으로 상위 <span class=\"token number\">5</span>\n  └─ <span class=\"token keyword\">JOIN</span> product <span class=\"token punctuation\">(</span>PK<span class=\"token punctuation\">)</span>\n       └─ <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> brand <span class=\"token punctuation\">(</span>PK<span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"성능과-비즈니스-요구사항-사이에서\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5%EA%B3%BC-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%82%AC%EC%9D%B4%EC%97%90%EC%84%9C\" aria-label=\"성능과 비즈니스 요구사항 사이에서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능과 비즈니스 요구사항 사이에서</h2>\n<p>하지만 이 완벽해 보이는 해결책에는, 한 가지 치명적인 비즈니스적 함정이 숨어있었다. like_summary를 <code class=\"language-text\">Driving Table</code>로 삼는 순간, 이 쿼리는 사실상 <code class=\"language-text\">INNER JOIN</code> 처럼 동작하게 된다.</p>\n<p>즉, like_summary 테이블에 데이터가 없는 상품, 다시 말해 '좋아요가 0개인 상품'은 결과에서 제외된다</p>\n<p>그렇다면 product 테이블을 Driving Table로 유지하면서, '좋아요가 0개인 상품'도 포함하고, 성능도 잡는 완벽한 쿼리는 없을까?</p>\n<p>하나의 '이론적인' 방법이 있다. 상품이 생성될 때마다 like_summary 테이블에 like_count = 0인 데이터를 미리 만들어두는 것이다.</p>\n<p>하지만 이는 50만 개, 수백만 개의 상품 중 대부분을 차지할 '좋아요 0개' 상품을 위해 엄청난 저장 공간을 낭비하는 결과를 초래한다. 실용적이지 못한 방법이다.</p>\n<p>이 지점에서 우리는 중요한 사실을 마주하게 된다.  <strong>우리는 연구원이 아니라, 비즈니스 문제를 해결하는 개발자</strong>다.</p>\n<p>우리의 목표는 모든 엣지 케이스를 만족시키는 하나의 완벽한 쿼리를 찾는 것이 아니라, 주어진 제약 속에서 가장 합리적이고 효율적인 기능을 만들어내는 것이다.</p>\n<p>\"사용자가 '인기순'으로 정렬할 때, 정말로 '인기 없는(좋아요 0개)' 상품을 목록 상단에서 보고 싶어 할까?\"</p>\n<p>우리는 '좋아요순 정렬' 기능의 요구사항을 다음과 같이 재정의했다.</p>\n<p>\"좋아요순 정렬에서는, 좋아요가 1개 이상인 상품만 보여주자.\"\n이 작은 재정의를 통해 모든 문제가 해결되었다.</p>\n<p>'좋아요 0개' 상품은 '최신순'이나 '가격순' 정렬에서는 얼마든지 볼 수 있다. '인기순' 목록에서 그들을 의도적으로 제외하는 것은 오히려 사용자의 목적에 더 부합하는 UX일 수 있다.</p>\n<p>이 새로운 요구사항 아래에서, 우리의 STRAIGHT_JOIN 쿼리는 더 이상 '좋아요 0개 상품을 누락하는' 결함이 있는 쿼리가 아니다. 오히려 새로운 비즈니스 요구사항을 가장 완벽하고 효율적으로 만족시키는 최적의 쿼리가 된 것이다.</p>\n<h2 id=\"튜닝-여정-한눈에-보기\" style=\"position:relative;\"><a href=\"#%ED%8A%9C%EB%8B%9D-%EC%97%AC%EC%A0%95-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EA%B8%B0\" aria-label=\"튜닝 여정 한눈에 보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>튜닝 여정 한눈에 보기</h2>\n<p>이번 5.38초에서 0.03초에 이르는 기나긴 튜닝 여정을 한눈에 요약하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">단계</th>\n<th align=\"left\">쿼리/전략</th>\n<th align=\"left\">주요 증상/계획</th>\n<th align=\"left\">시간</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code class=\"language-text\">JOIN</code> + <code class=\"language-text\">GROUP BY</code> + <code class=\"language-text\">ORDER BY</code></td>\n<td align=\"left\"><code class=\"language-text\">Using temporary; Using filesort</code>, <code class=\"language-text\">p: type=ALL</code></td>\n<td align=\"left\"><strong>5.38s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code class=\"language-text\">price</code> 인덱스만 추가</td>\n<td align=\"left\">여전히 <code class=\"language-text\">GROUP BY</code>가 막음</td>\n<td align=\"left\"><strong>5.35s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">구조변경 (서브쿼리로 <code class=\"language-text\">likeCount</code>)</td>\n<td align=\"left\">임시테이블 제거, <code class=\"language-text\">filesort</code>만 남음</td>\n<td align=\"left\"><strong>0.63s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">+ <code class=\"language-text\">price</code> 인덱스 활용</td>\n<td align=\"left\">인덱스 순서로 상위 N만 읽기</td>\n<td align=\"left\"><strong>0.06s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">집계테이블 도입 (<code class=\"language-text\">ORDER BY price</code>)</td>\n<td align=\"left\"><code class=\"language-text\">filesort</code> 없음, 안정적인 성능 확인</td>\n<td align=\"left\"><strong>0.05s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">집계테이블 도입 (<code class=\"language-text\">ORDER BY like_count</code>)</td>\n<td align=\"left\"><code class=\"language-text\">Using filesort</code>, <code class=\"language-text\">p</code>가 드라이빙 테이블</td>\n<td align=\"left\"><strong>1.92s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><code class=\"language-text\">like_count</code> 단일 인덱스</td>\n<td align=\"left\">옵티마이저가 무시 (비용상 불리)</td>\n<td align=\"left\"><strong>1.86s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><code class=\"language-text\">(target_type, like_count)</code> 복합 인덱스</td>\n<td align=\"left\">여전히 <code class=\"language-text\">p</code>가 드라이빙</td>\n<td align=\"left\"><strong>1.84s</strong></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><code class=\"language-text\">STRAIGHT_JOIN</code>로 <code class=\"language-text\">s</code> → <code class=\"language-text\">p</code></td>\n<td align=\"left\">인덱스 역스캔, 상위 N 선별 후 <code class=\"language-text\">JOIN</code></td>\n<td align=\"left\"><strong>0.03s</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"맺으며\" style=\"position:relative;\"><a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\" aria-label=\"맺으며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>맺으며</h2>\n<h3 id=\"인덱스는-감이-아닌-데이터로-설계한다\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%8A%94-%EA%B0%90%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%9C%EB%8B%A4\" aria-label=\"인덱스는 감이 아닌 데이터로 설계한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스는 감이 아닌 데이터로 설계한다.</h3>\n<p>이번 성능 튜닝을 통해 배운 교훈을 다시 정리하면 다음과 같다.</p>\n<ol>\n<li>\n<p><strong>단일 쿼리의 편리함이 항상 성능을 보장하지는 않았다.</strong> <br/> :JOIN과 GROUP BY의 간결함 이면에는 <code class=\"language-text\">Using temporary;</code> <code class=\"language-text\">Using filesort</code>라는 거대한 비용이 숨어있을 수 있었고, 실행 계획은 그 실제 비용을 보여주는 가장 정직한 지표였다.</p>\n</li>\n<li>\n<p><strong>인덱스는 생성보다 '활용'이 더 중요했다.</strong> <br/> :쿼리 구조 자체가 인덱스를 활용할 수 없도록 설계되었거나, 옵티마이저가 비효율적인 테이블부터 읽기 시작한다면 인덱스는 무용지물이었다.</p>\n</li>\n<li>\n<p><strong>옵티마이저의 판단이 항상 최선은 아니었다.</strong> <br/> :비용 기반으로 동작하는 옵티마이저가 데이터의 분포나 쿼리의 복잡성 때문에 때로는 최적의 실행 계획을 찾지 못했다. 이런 상황에서는 STRAIGHT_JOIN 같은 힌트를 통해 개발자가 직접 실행 계획에 개입하는 것이 효과적인 해결책이 될 수 있었다.</p>\n</li>\n<li>\n<p><strong>모든 결정은 추측이 아닌 데이터에 기반해야 한다.</strong> <br/> :EXPLAIN과 k6가 보여주는 객관적인 데이터만이 '감'에 의존한 예상을 바로잡고, 가장 신뢰할 수 있는 개선의 방향을 알려주었다.</p>\n</li>\n</ol>\n<p>결국 \"인덱스를 걸었다\"는 사실에 안주하는 것이 아니라, 데이터베이스가 어떻게 동작하는지 이해하고, 실행 계획이라는 데이터를 근거로 꾸준히 의심하고 검증하는 과정이야말로 서비스의 안정성을 지키는 가장 중요한 습관임을 다시 한번 느꼈다.</p>","timeToRead":11,"frontmatter":{"title":"인덱스를 걸었는데, 왜 느리죠? (feat. 5초를 0.03초로 만든 쿼리 삽질기) ","summary":null,"date":"2025-08-15","categories":["index"],"thumbnail":null}}}]}},"pageContext":{"slug":"/why-is-my-query-slow-after-indexing/"}},"staticQueryHashes":[],"slicesMap":{}}